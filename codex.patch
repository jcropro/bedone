diff --git a/AGENTS.md b/AGENTS.md
index 41a50f8b1da702599863226bb7c4b18ddaaea81b..b9d3132abbc4fbf721cd895b807e9d2e70238640 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -1,26 +1,19 @@
-﻿# AGENTS.md — Ember Audio Player (Android)
-
-Follow docs/MASTER_PROMPT.md exactly.
+# AGENTS.md — EmberAudioPlayer3 Android
 
-Absolute rules:
-- Windows paths only. Create every missing folder/file before referencing.
-- When updating a file, output the FULL FINAL FILE (no diffs).
-- Kotlin 2.1.20, Compose via BOM (no kotlinCompilerExtensionVersion), AGP 8.12.0, Gradle 8.13. AndroidX only.
-- minSdk 24; target/compile 35; Media3 1.8.0 playback; no legacy support libs.
-- Do NOT build Android in the cloud. Generate correct files; I will compile locally.
-- Work in phases. After each phase: commit → push to 'codex/dev' → open a PR → STOP.
-
-## Internet allowlist (comma-separated)
-developer.android.com,kotlinlang.org,kdoc.dev,javadoc.io,services.gradle.org,plugins.gradle.org,dl.google.com,maven.google.com,repo.maven.apache.org,repo1.maven.org,musicbrainz.org,coverartarchive.org,itunes.apple.com
-
-## Internet policy (cloud tasks that CAN edit the repo)
-Allowed (GET/HEAD only) to the domains above.
-Banned: uploading repo code/secrets; installing SDKs/packages; 'curl | bash'; auto-bumping versions.
-If a new domain is needed, propose it in the PR; do not proceed without approval.
-
-## Self-audit before each commit
-- Only AndroidX/Media3 imports; all referenced resources exist; versions match pins.
+Follow `docs/MASTER_PROMPT.md` for workflow and guardrails.
 
-## Fallbacks used for compileSdk 35
-- androidx.core:core-ktx 1.16.0 (instead of 1.17.0 which requires compileSdk 36)
-- androidx.activity:activity-compose 1.10.1 (instead of 1.11.0 which requires compileSdk 36)
+Pinned tooling versions:
+- Android Gradle Plugin 8.12.0 with Gradle 8.13
+- Kotlin 2.1.20 (K2)
+- Compose BOM 2025.06.00
+- Media3 1.8.0
+- Activity Compose 1.9.2
+- core-ktx 1.12.0
+- minSdk 24, target/compile 35
+
+Guardrails:
+- Use AndroidX (and Kotlin stdlib/coroutines) dependencies only.
+- No Hilt/KSP in this baseline.
+- Keep the project compiling locally; no cloud builds.
+- Emit full file contents when modifying files.
+- Cite official sources when documenting version or API choices.
diff --git a/STATE b/STATE
index 3bc76afab02524edcdea19ecad3952e5d51ae06b..946a1d3ada1121ea527c7f97f4fbdb466ec0de7f 100644
--- a/STATE
+++ b/STATE
@@ -1,10 +1,13 @@
-LEFT_OFF_AT: M1 features — Library sorting
+LEFT_OFF_AT: Search overlay now surfaces bucketed results with playback hand-off.
 
 NEXT_ACTIONS:
-- QA: Albums/Artists sorting (A–Z / Z–A) and Songs sorting (Title/Date/Duration) persist and update immediately.
-- QA: excluded folders; playback speed + share; Now Playing toggles and ±10s; queue swipe-to-dismiss; album/artist headers + thumbs; playlist rename/delete; settings toggles/sliders; search filters/highlighting.
-- Build/QA: assembleDebug; smoke-test scanning, playback, queue persistence; report issues.
+- QA: Confirm search overlay buckets, view-all affordances, and TalkBack labels behave correctly.
+- QA: Confirm shuffle/play-all buttons start playback from the correct songs and respect accessibility text.
+- QA: Confirm share affordances open the chooser with correct copy from both the Songs list and Now Playing card.
+- QA: Validate equalizer/bass/virtualizer toggles persist across tab changes and re-openings.
+- Follow-up slices: playlist rename/delete, settings toggles/sliders, queue drag reordering.
+- Build/QA: assembleDebug; smoke-test scanning, playback, queue persistence; report issues (requires local SDK).
 
 BLOCKERS:
 - Build/QA requires local environment (per no-cloud-build rule).
 - “Reuse Coil.imageLoader” replaced by palette cache due to AndroidX-only constraint.
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
new file mode 100644
index 0000000000000000000000000000000000000000..1a2ea03d0bfce31393c4d1fe902ca7200eb35850
--- /dev/null
+++ b/app/build.gradle.kts
@@ -0,0 +1,79 @@
+plugins {
+    id("com.android.application")
+    id("org.jetbrains.kotlin.android")
+    id("org.jetbrains.kotlin.plugin.compose")
+}
+
+android {
+    namespace = "app.ember.studio"
+    compileSdk = 35
+
+    defaultConfig {
+        applicationId = "app.ember.studio"
+        minSdk = 24
+        targetSdk = 35
+        versionCode = 1
+        versionName = "0.2.0"
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+        vectorDrawables.useSupportLibrary = true
+    }
+
+    buildTypes {
+        release {
+            isMinifyEnabled = true
+            proguardFiles(
+                getDefaultProguardFile("proguard-android-optimize.txt"),
+                "proguard-rules.pro"
+            )
+        }
+        debug {
+            isMinifyEnabled = false
+        }
+    }
+
+    buildFeatures {
+        compose = true
+    }
+
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_17
+        targetCompatibility = JavaVersion.VERSION_17
+    }
+
+    kotlinOptions {
+        jvmTarget = "17"
+    }
+
+    packaging {
+        resources {
+            excludes += "/META-INF/{AL2.0,LGPL2.1}"
+        }
+    }
+}
+
+dependencies {
+    implementation(platform("androidx.compose:compose-bom:2025.06.00"))
+    implementation("androidx.compose.ui:ui")
+    implementation("androidx.compose.ui:ui-tooling-preview")
+    implementation("androidx.compose.foundation:foundation")
+    implementation("androidx.compose.material3:material3")
+    implementation("androidx.compose.material:material-icons-extended")
+    debugImplementation("androidx.compose.ui:ui-tooling")
+    debugImplementation("androidx.compose.ui:ui-test-manifest")
+
+    implementation("androidx.activity:activity-compose:1.9.2")
+    implementation("androidx.core:core-ktx:1.12.0")
+    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
+    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.7.0")
+    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
+
+    implementation("androidx.media3:media3-exoplayer:1.8.0")
+
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1")
+
+    testImplementation("junit:junit:4.13.2")
+    androidTestImplementation(platform("androidx.compose:compose-bom:2025.06.00"))
+    androidTestImplementation("androidx.test.ext:junit:1.2.1")
+    androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
+    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
+}
diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
new file mode 100644
index 0000000000000000000000000000000000000000..398a4c7942ed90666a0088fa50687fe6f29eae12
--- /dev/null
+++ b/app/proguard-rules.pro
@@ -0,0 +1 @@
+# No additional rules required for the current configuration.
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000000000000000000000000000000000..61641e65b22b719817fb886481ceec93f2a45389
--- /dev/null
+++ b/app/src/main/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:roundIcon="@mipmap/ic_launcher_round"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.EmberAudioStudio3">
+        <activity
+            android:name=".MainActivity"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/app/src/main/java/app/ember/studio/EmberAudioPlayerApp.kt b/app/src/main/java/app/ember/studio/EmberAudioPlayerApp.kt
new file mode 100644
index 0000000000000000000000000000000000000000..57d20d8e1a467a03fee1a6e346e3e81dbc9db542
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/EmberAudioPlayerApp.kt
@@ -0,0 +1,2191 @@
+package app.ember.studio
+
+import androidx.activity.compose.BackHandler
+import androidx.annotation.StringRes
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.statusBarsPadding
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.navigationBarsPadding
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.LazyRow
+import androidx.compose.foundation.lazy.items
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.Menu
+import androidx.compose.material.icons.outlined.Album
+import androidx.compose.material.icons.outlined.ArrowDownward
+import androidx.compose.material.icons.outlined.ArrowUpward
+import androidx.compose.material.icons.outlined.Check
+import androidx.compose.material.icons.outlined.Close
+import androidx.compose.material.icons.outlined.Delete
+import androidx.compose.material.icons.outlined.Equalizer
+import androidx.compose.material.icons.outlined.HelpOutline
+import androidx.compose.material.icons.outlined.LibraryMusic
+import androidx.compose.material.icons.outlined.Palette
+import androidx.compose.material.icons.outlined.Pause
+import androidx.compose.material.icons.outlined.PlayArrow
+import androidx.compose.material.icons.outlined.QueueMusic
+import androidx.compose.material.icons.outlined.Search
+import androidx.compose.material.icons.outlined.Settings
+import androidx.compose.material.icons.outlined.Share
+import androidx.compose.material.icons.outlined.Timer
+import androidx.compose.material.icons.outlined.SkipNext
+import androidx.compose.material.icons.outlined.SkipPrevious
+import androidx.compose.material.icons.outlined.Sort
+import androidx.compose.material.icons.outlined.VideoLibrary
+import androidx.compose.material.icons.outlined.Widget
+import androidx.compose.material.DismissDirection
+import androidx.compose.material.DismissState
+import androidx.compose.material.DismissValue
+import androidx.compose.material.ExperimentalMaterialApi
+import androidx.compose.material.SwipeToDismiss
+import androidx.compose.material.rememberDismissState
+import androidx.compose.material3.AssistChip
+import androidx.compose.material3.Button
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.CenterAlignedTopAppBar
+import androidx.compose.material3.Divider
+import androidx.compose.material3.DrawerValue
+import androidx.compose.material3.ElevatedCard
+import androidx.compose.material3.ElevatedFilterChip
+import androidx.compose.material3.FilterChip
+import androidx.compose.material3.FilledTonalButton
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.ListItem
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.ModalBottomSheet
+import androidx.compose.material3.ModalNavigationDrawer
+import androidx.compose.material3.NavigationDrawerItem
+import androidx.compose.material3.NavigationDrawerItemDefaults
+import androidx.compose.material3.OutlinedTextField
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.ScrollableTabRow
+import androidx.compose.material3.Slider
+import androidx.compose.material3.Surface
+import androidx.compose.material3.Tab
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextButton
+import androidx.compose.material3.DropdownMenu
+import androidx.compose.material3.DropdownMenuItem
+import androidx.compose.material3.rememberDrawerState
+import androidx.compose.material3.rememberModalBottomSheetState
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.runtime.saveable.rememberSaveable
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.res.stringResource
+import androidx.compose.foundation.text.KeyboardActions
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.text.input.ImeAction
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.semantics.semantics
+import app.ember.studio.SearchBucket
+import app.ember.studio.SearchCorpus
+import app.ember.studio.SearchResults
+import app.ember.studio.SearchUiState
+import app.ember.studio.searchLibrary
+import app.ember.studio.ui.theme.EmberAudioPlayerTheme
+import app.ember.studio.ui.theme.ThemeUiState
+import app.ember.studio.util.formatDuration
+import androidx.compose.foundation.rememberScrollState
+import kotlinx.coroutines.launch
+import app.ember.studio.LongformCategory
+import app.ember.studio.OnboardingUiState
+
+@Composable
+fun EmberAudioPlayerApp(
+    homeState: HomeUiState,
+    playerState: PlayerUiState,
+    equalizerState: EqualizerUiState,
+    lyricsState: LyricsUiState,
+    themeState: ThemeUiState,
+    tagEditorState: TagEditorUiState,
+    onboardingState: OnboardingUiState,
+    onTogglePlayPause: () -> Unit,
+    onSeekTo: (Long) -> Unit,
+    onEqualizerEnabledChange: (Boolean) -> Unit,
+    onBandLevelChange: (Int, Int) -> Unit,
+    onPresetSelected: (Int) -> Unit,
+    onBassBoostChange: (Int) -> Unit,
+    onVirtualizerChange: (Int) -> Unit,
+    onReverbSelected: (Short) -> Unit,
+    onLyricsDraftChange: (String) -> Unit,
+    onLyricsSave: () -> Unit,
+    onLyricsClear: () -> Unit,
+    onSampleLyrics: () -> Unit,
+    onSelectThemeOption: (Int) -> Unit,
+    onToggleDarkTheme: (Boolean) -> Unit,
+    onUpdateTagTitle: (String) -> Unit,
+    onUpdateTagArtist: (String) -> Unit,
+    onUpdateTagAlbum: (String) -> Unit,
+    onSaveTags: () -> Unit,
+    onResetTags: () -> Unit,
+    onShareCurrentSong: () -> Unit,
+    onShareSong: (String) -> Unit,
+    onTabSelected: (HomeTab) -> Unit,
+    onDrawerDestinationSelected: (DrawerDestinationId) -> Unit,
+    onSongSelected: (String) -> Unit,
+    onPlayAllSongs: () -> Unit,
+    onShuffleAllSongs: () -> Unit,
+    songSort: SongSortState,
+    albumSortDirection: SortDirection,
+    artistSortDirection: SortDirection,
+    onSongSortFieldSelected: (SongSortField) -> Unit,
+    onSongSortDirectionToggle: () -> Unit,
+    onAlbumSortToggle: () -> Unit,
+    onArtistSortToggle: () -> Unit,
+    onToggleQueue: () -> Unit,
+    onDismissQueue: () -> Unit,
+    onRemoveFromQueue: (String) -> Unit,
+    onPlayNext: () -> Unit,
+    onPlayPrevious: () -> Unit,
+    onSelectLongformFilter: (LongformFilter) -> Unit,
+    onOnboardingWelcomeContinue: () -> Unit,
+    onRequestAudioPermission: () -> Unit,
+    onChooseFolders: () -> Unit,
+    onAssignAllLongform: (LongformCategory) -> Unit,
+    onChooseLongformIndividually: () -> Unit,
+    onLongformSelectionChange: (String, LongformCategory) -> Unit,
+    onApplyLongformSelection: () -> Unit,
+    onSkipLongform: () -> Unit,
+    onUndoLongformChange: () -> Unit,
+    onConsumeOnboardingMessage: () -> Unit,
+    onCompleteOnboarding: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    EmberAudioPlayerTheme(themeState = themeState) {
+        val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
+        val queueSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
+        val nowPlayingSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
+        val lyricsSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
+        val tagSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
+        val scope = rememberCoroutineScope()
+
+        var showNowPlayingSheet by rememberSaveable { mutableStateOf(false) }
+        var showLyricsSheet by rememberSaveable { mutableStateOf(false) }
+        var showTagEditorSheet by rememberSaveable { mutableStateOf(false) }
+        var isSearchVisible by rememberSaveable { mutableStateOf(false) }
+        var searchQuery by rememberSaveable { mutableStateOf("") }
+        var activeSearchBucket by rememberSaveable { mutableStateOf(SearchBucket.All) }
+
+        val searchResults = remember(homeState, searchQuery) {
+            if (searchQuery.isBlank()) {
+                SearchResults()
+            } else {
+                searchLibrary(
+                    SearchCorpus(
+                        songs = homeState.songs,
+                        playlists = homeState.playlists,
+                        folders = homeState.folders,
+                        albums = homeState.albums,
+                        artists = homeState.artists,
+                        genres = homeState.genres,
+                        longform = homeState.longformItems,
+                        videos = homeState.videos
+                    ),
+                    searchQuery
+                )
+            }
+        }
+        val isSearchEmpty = searchQuery.isNotBlank() && searchResults.isEmpty
+        val searchUiState = remember(searchQuery, activeSearchBucket, searchResults, isSearchEmpty) {
+            SearchUiState(
+                query = searchQuery,
+                bucket = activeSearchBucket,
+                results = searchResults,
+                isEmpty = isSearchEmpty
+            )
+        }
+
+        if (homeState.isQueueVisible) {
+            ModalBottomSheet(
+                onDismissRequest = onDismissQueue,
+                sheetState = queueSheetState
+            ) {
+                QueueSheet(
+                    queueState = homeState.queue,
+                    onSongSelected = onSongSelected,
+                    onRemoveFromQueue = onRemoveFromQueue,
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .padding(bottom = 24.dp)
+                )
+            }
+        }
+
+        if (showNowPlayingSheet) {
+            ModalBottomSheet(
+                onDismissRequest = { showNowPlayingSheet = false },
+                sheetState = nowPlayingSheetState
+            ) {
+                NowPlayingScreen(
+                    state = playerState,
+                    onTogglePlayPause = onTogglePlayPause,
+                    onSeekTo = onSeekTo,
+                    onShowLyrics = { showLyricsSheet = true },
+                    onShowTagEditor = { showTagEditorSheet = true },
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .padding(bottom = 32.dp)
+                )
+            }
+        }
+
+        if (showLyricsSheet) {
+            ModalBottomSheet(
+                onDismissRequest = { showLyricsSheet = false },
+                sheetState = lyricsSheetState
+            ) {
+                LyricsScreen(
+                    state = lyricsState,
+                    onDraftChange = onLyricsDraftChange,
+                    onSave = {
+                        onLyricsSave()
+                        showLyricsSheet = false
+                    },
+                    onClear = onLyricsClear,
+                    onLoadSample = onSampleLyrics,
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .padding(bottom = 24.dp)
+                )
+            }
+        }
+
+        if (showTagEditorSheet) {
+            ModalBottomSheet(
+                onDismissRequest = { showTagEditorSheet = false },
+                sheetState = tagSheetState
+            ) {
+                TagEditorScreen(
+                    state = tagEditorState,
+                    onTitleChange = onUpdateTagTitle,
+                    onArtistChange = onUpdateTagArtist,
+                    onAlbumChange = onUpdateTagAlbum,
+                    onSave = {
+                        onSaveTags()
+                        showTagEditorSheet = false
+                    },
+                    onReset = onResetTags,
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .padding(bottom = 24.dp)
+                )
+            }
+        }
+
+        Box(modifier = modifier.fillMaxSize()) {
+            ModalNavigationDrawer(
+                drawerState = drawerState,
+                drawerContent = {
+                    DrawerContent(
+                        destinations = homeState.drawerDestinations,
+                        selected = homeState.selectedDrawerDestination,
+                        onDestinationSelected = {
+                            onDrawerDestinationSelected(it)
+                            scope.launch { drawerState.close() }
+                        }
+                    )
+                }
+            ) {
+                Scaffold(
+                    topBar = {
+                        LibraryTopBar(
+                            onOpenDrawer = { scope.launch { drawerState.open() } },
+                            onSearch = {
+                                activeSearchBucket = SearchBucket.All
+                                isSearchVisible = true
+                            },
+                            onOpenThemeStudio = {
+                                onDrawerDestinationSelected(DrawerDestinationId.ThemeStudio)
+                            },
+                            onOpenSettings = {
+                                onDrawerDestinationSelected(DrawerDestinationId.Settings)
+                            }
+                        )
+                    },
+                    bottomBar = {
+                        MiniPlayer(
+                            state = playerState,
+                            onTogglePlayPause = onTogglePlayPause,
+                            onPlayNext = onPlayNext,
+                            onPlayPrevious = onPlayPrevious,
+                            onOpenNowPlaying = { showNowPlayingSheet = true },
+                            onShowQueue = onToggleQueue,
+                            modifier = Modifier.navigationBarsPadding()
+                        )
+                    },
+                    modifier = Modifier.fillMaxSize()
+                ) { innerPadding ->
+                    when (homeState.selectedDrawerDestination) {
+                    DrawerDestinationId.Library -> LibraryContent(
+                        homeState = homeState,
+                        playerState = playerState,
+                        equalizerState = equalizerState,
+                        lyricsState = lyricsState,
+                        themeState = themeState,
+                        tagEditorState = tagEditorState,
+                        onTogglePlayPause = onTogglePlayPause,
+                        onSeekTo = onSeekTo,
+                        onTabSelected = onTabSelected,
+                        onSongSelected = {
+                            onSongSelected(it)
+                            showNowPlayingSheet = true
+                        },
+                        onShowLyrics = { showLyricsSheet = true },
+                        onShowTagEditor = { showTagEditorSheet = true },
+                        onEqualizerEnabledChange = onEqualizerEnabledChange,
+                        onBandLevelChange = onBandLevelChange,
+                        onPresetSelected = onPresetSelected,
+                        onBassBoostChange = onBassBoostChange,
+                        onVirtualizerChange = onVirtualizerChange,
+                        onReverbSelected = onReverbSelected,
+                        onLyricsDraftChange = onLyricsDraftChange,
+                        onLyricsSave = onLyricsSave,
+                        onLyricsClear = onLyricsClear,
+                        onSampleLyrics = onSampleLyrics,
+                        onSelectThemeOption = onSelectThemeOption,
+                        onToggleDarkTheme = onToggleDarkTheme,
+                        onUpdateTagTitle = onUpdateTagTitle,
+                        onUpdateTagArtist = onUpdateTagArtist,
+                        onUpdateTagAlbum = onUpdateTagAlbum,
+                        onSaveTags = onSaveTags,
+                        onResetTags = onResetTags,
+                        onSelectLongformFilter = onSelectLongformFilter,
+                        contentPadding = innerPadding
+                    )
+                    DrawerDestinationId.Equalizer -> EqualizerScreen(
+                        state = equalizerState,
+                        onEqualizerEnabledChange = onEqualizerEnabledChange,
+                        onBandLevelChange = onBandLevelChange,
+                        onPresetSelected = onPresetSelected,
+                        onBassBoostChange = onBassBoostChange,
+                        onVirtualizerChange = onVirtualizerChange,
+                        onReverbSelected = onReverbSelected,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                            .padding(horizontal = 24.dp, vertical = 16.dp)
+                    )
+                    DrawerDestinationId.ThemeStudio -> ThemeScreen(
+                        state = themeState,
+                        onSelectOption = onSelectThemeOption,
+                        onToggleDarkTheme = onToggleDarkTheme,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                            .padding(horizontal = 24.dp, vertical = 16.dp)
+                    )
+                    DrawerDestinationId.SleepTimer -> PlaceholderScreen(
+                        titleRes = R.string.drawer_sleep_timer,
+                        messageRes = R.string.placeholder_sleep_timer,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                    )
+                    DrawerDestinationId.Widgets -> PlaceholderScreen(
+                        titleRes = R.string.drawer_widgets,
+                        messageRes = R.string.placeholder_widgets,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                    )
+                    DrawerDestinationId.ScanImport -> PlaceholderScreen(
+                        titleRes = R.string.drawer_scan_import,
+                        messageRes = R.string.placeholder_scan_import,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                    )
+                    DrawerDestinationId.Settings -> PlaceholderScreen(
+                        titleRes = R.string.drawer_settings,
+                        messageRes = R.string.placeholder_settings,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                    )
+                    DrawerDestinationId.Help -> PlaceholderScreen(
+                        titleRes = R.string.drawer_help,
+                        messageRes = R.string.placeholder_help,
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(innerPadding)
+                    )
+                }
+                }
+            }
+            if (onboardingState.isVisible) {
+                OnboardingOverlay(
+                    state = onboardingState,
+                    themeState = themeState,
+                    onWelcomeContinue = onOnboardingWelcomeContinue,
+                    onRequestPermission = onRequestAudioPermission,
+                    onChooseFolders = onChooseFolders,
+                    onAssignAllLongform = onAssignAllLongform,
+                    onChooseIndividually = onChooseLongformIndividually,
+                    onSelectionChange = onLongformSelectionChange,
+                    onApplySelection = onApplyLongformSelection,
+                    onSkip = onSkipLongform,
+                    onUndo = onUndoLongformChange,
+                    onDismissMessage = onConsumeOnboardingMessage,
+                    onComplete = onCompleteOnboarding,
+                    onSelectThemeOption = onSelectThemeOption,
+                    onToggleDarkTheme = onToggleDarkTheme
+                )
+            }
+            if (isSearchVisible) {
+                SearchOverlay(
+                    state = searchUiState,
+                    onDismiss = {
+                        isSearchVisible = false
+                    },
+                    onQueryChange = { query ->
+                        searchQuery = query
+                    },
+                    onClearQuery = {
+                        searchQuery = ""
+                    },
+                    onBucketSelected = { bucket ->
+                        activeSearchBucket = bucket
+                    },
+                    onSongSelected = { songId ->
+                        onSongSelected(songId)
+                        showNowPlayingSheet = true
+                        isSearchVisible = false
+                    },
+                    onNavigateToTab = { tab ->
+                        onDrawerDestinationSelected(DrawerDestinationId.Library)
+                        onTabSelected(tab)
+                        isSearchVisible = false
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun SearchOverlay(
+    state: SearchUiState,
+    onDismiss: () -> Unit,
+    onQueryChange: (String) -> Unit,
+    onClearQuery: () -> Unit,
+    onBucketSelected: (SearchBucket) -> Unit,
+    onSongSelected: (String) -> Unit,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    BackHandler(onBack = onDismiss)
+    Surface(
+        modifier = Modifier
+            .fillMaxSize()
+            .semantics { contentDescription = stringResource(R.string.search_overlay_content_description) }
+    ) {
+        Column(modifier = Modifier.fillMaxSize()) {
+            Row(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .statusBarsPadding()
+                    .padding(horizontal = 16.dp, vertical = 8.dp),
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                IconButton(onClick = onDismiss) {
+                    Icon(
+                        imageVector = Icons.Outlined.Close,
+                        contentDescription = stringResource(R.string.search_close_content_description)
+                    )
+                }
+                Text(
+                    text = stringResource(R.string.search_title),
+                    style = MaterialTheme.typography.titleLarge,
+                    modifier = Modifier.padding(start = 8.dp)
+                )
+            }
+            OutlinedTextField(
+                value = state.query,
+                onValueChange = onQueryChange,
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .padding(horizontal = 24.dp),
+                placeholder = { Text(text = stringResource(R.string.search_field_placeholder)) },
+                singleLine = true,
+                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Search),
+                keyboardActions = KeyboardActions(onSearch = { onDismiss() }),
+                trailingIcon = {
+                    if (state.query.isNotBlank()) {
+                        IconButton(onClick = onClearQuery) {
+                            Icon(
+                                imageVector = Icons.Outlined.Close,
+                                contentDescription = stringResource(R.string.search_clear_content_description)
+                            )
+                        }
+                    }
+                }
+            )
+            LazyRow(
+                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 12.dp),
+                horizontalArrangement = Arrangement.spacedBy(8.dp)
+            ) {
+                items(SearchBucket.entries) { bucket ->
+                    FilterChip(
+                        selected = state.bucket == bucket,
+                        onClick = { onBucketSelected(bucket) },
+                        label = { Text(text = stringResource(bucket.labelRes)) }
+                    )
+                }
+            }
+            when {
+                state.query.isBlank() -> {
+                    SearchPlaceholder(textRes = R.string.search_hint)
+                }
+                state.isEmpty -> {
+                    SearchPlaceholder(textRes = R.string.search_no_results)
+                }
+                else -> {
+                    when (state.bucket) {
+                        SearchBucket.All -> SearchAllResults(
+                            results = state.results,
+                            onSongSelected = onSongSelected,
+                            onBucketSelected = onBucketSelected,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Songs -> SearchSongsResults(
+                            songs = state.results.songs,
+                            onSongSelected = onSongSelected
+                        )
+                        SearchBucket.Playlists -> SearchPlaylistsResults(
+                            playlists = state.results.playlists,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Folders -> SearchFoldersResults(
+                            folders = state.results.folders,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Albums -> SearchAlbumsResults(
+                            albums = state.results.albums,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Artists -> SearchArtistsResults(
+                            artists = state.results.artists,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Genres -> SearchGenresResults(
+                            genres = state.results.genres,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Longform -> SearchLongformResults(
+                            items = state.results.longform,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                        SearchBucket.Videos -> SearchVideosResults(
+                            videos = state.results.videos,
+                            onNavigateToTab = onNavigateToTab
+                        )
+                    }
+                }
+            }
+        }
+    }
+}
+
+@Composable
+private fun SearchPlaceholder(@StringRes textRes: Int) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(horizontal = 32.dp, vertical = 24.dp),
+        verticalArrangement = Arrangement.Center,
+        horizontalAlignment = Alignment.CenterHorizontally
+    ) {
+        Text(
+            text = stringResource(textRes),
+            style = MaterialTheme.typography.bodyLarge,
+            textAlign = TextAlign.Center
+        )
+    }
+}
+
+@Composable
+private fun SearchAllResults(
+    results: SearchResults,
+    onSongSelected: (String) -> Unit,
+    onBucketSelected: (SearchBucket) -> Unit,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(16.dp)
+    ) {
+        if (results.songs.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_songs) }
+            items(results.songs.take(4)) { song ->
+                SongSearchRow(song = song, onClick = { onSongSelected(song.id) })
+            }
+            if (results.songs.size > 4) {
+                item {
+                    ViewAllButton(onClick = { onBucketSelected(SearchBucket.Songs) })
+                }
+            }
+        }
+        if (results.playlists.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_playlists) }
+            items(results.playlists.take(4)) { playlist ->
+                PlaylistSearchRow(playlist = playlist, onClick = { onNavigateToTab(HomeTab.Playlists) })
+            }
+            if (results.playlists.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Playlists) }) }
+            }
+        }
+        if (results.folders.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_folders) }
+            items(results.folders.take(4)) { folder ->
+                FolderSearchRow(folder = folder, onClick = { onNavigateToTab(HomeTab.Folders) })
+            }
+            if (results.folders.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Folders) }) }
+            }
+        }
+        if (results.albums.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_albums) }
+            items(results.albums.take(4)) { album ->
+                AlbumSearchRow(album = album, onClick = { onNavigateToTab(HomeTab.Albums) })
+            }
+            if (results.albums.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Albums) }) }
+            }
+        }
+        if (results.artists.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_artists) }
+            items(results.artists.take(4)) { artist ->
+                ArtistSearchRow(artist = artist, onClick = { onNavigateToTab(HomeTab.Artists) })
+            }
+            if (results.artists.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Artists) }) }
+            }
+        }
+        if (results.genres.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_genres) }
+            items(results.genres.take(4)) { genre ->
+                GenreSearchRow(genre = genre, onClick = { onNavigateToTab(HomeTab.Genres) })
+            }
+            if (results.genres.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Genres) }) }
+            }
+        }
+        if (results.longform.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_longform) }
+            items(results.longform.take(4)) { item ->
+                LongformSearchRow(item = item, onClick = { onNavigateToTab(HomeTab.Longform) })
+            }
+            if (results.longform.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Longform) }) }
+            }
+        }
+        if (results.videos.isNotEmpty()) {
+            item { SearchSectionHeader(titleRes = R.string.search_section_videos) }
+            items(results.videos.take(4)) { video ->
+                VideoSearchRow(video = video, onClick = { onNavigateToTab(HomeTab.Videos) })
+            }
+            if (results.videos.size > 4) {
+                item { ViewAllButton(onClick = { onBucketSelected(SearchBucket.Videos) }) }
+            }
+        }
+    }
+}
+
+@Composable
+private fun SearchSongsResults(
+    songs: List<SongSummary>,
+    onSongSelected: (String) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(songs) { song ->
+            SongSearchRow(song = song, onClick = { onSongSelected(song.id) })
+        }
+    }
+}
+
+@Composable
+private fun SearchPlaylistsResults(
+    playlists: List<PlaylistSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(playlists) { playlist ->
+            PlaylistSearchRow(playlist = playlist, onClick = { onNavigateToTab(HomeTab.Playlists) })
+        }
+    }
+}
+
+@Composable
+private fun SearchFoldersResults(
+    folders: List<FolderSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(folders) { folder ->
+            FolderSearchRow(folder = folder, onClick = { onNavigateToTab(HomeTab.Folders) })
+        }
+    }
+}
+
+@Composable
+private fun SearchAlbumsResults(
+    albums: List<AlbumSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(albums) { album ->
+            AlbumSearchRow(album = album, onClick = { onNavigateToTab(HomeTab.Albums) })
+        }
+    }
+}
+
+@Composable
+private fun SearchArtistsResults(
+    artists: List<ArtistSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(artists) { artist ->
+            ArtistSearchRow(artist = artist, onClick = { onNavigateToTab(HomeTab.Artists) })
+        }
+    }
+}
+
+@Composable
+private fun SearchGenresResults(
+    genres: List<GenreSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(genres) { genre ->
+            GenreSearchRow(genre = genre, onClick = { onNavigateToTab(HomeTab.Genres) })
+        }
+    }
+}
+
+@Composable
+private fun SearchLongformResults(
+    items: List<LongformItem>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(items) { item ->
+            LongformSearchRow(item = item, onClick = { onNavigateToTab(HomeTab.Longform) })
+        }
+    }
+}
+
+@Composable
+private fun SearchVideosResults(
+    videos: List<VideoSummary>,
+    onNavigateToTab: (HomeTab) -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        items(videos) { video ->
+            VideoSearchRow(video = video, onClick = { onNavigateToTab(HomeTab.Videos) })
+        }
+    }
+}
+
+@Composable
+private fun SearchSectionHeader(@StringRes titleRes: Int) {
+    Text(
+        text = stringResource(titleRes),
+        style = MaterialTheme.typography.titleMedium,
+        modifier = Modifier.fillMaxWidth()
+    )
+}
+
+@Composable
+private fun ViewAllButton(onClick: () -> Unit) {
+    TextButton(onClick = onClick) {
+        Text(text = stringResource(R.string.search_view_all))
+    }
+}
+
+@Composable
+private fun SongSearchRow(song: SongSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = song.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(R.string.song_row_subtitle, song.artist, song.album),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            },
+            trailingContent = {
+                Text(text = formatDuration(song.durationMs))
+            }
+        )
+    }
+}
+
+@Composable
+private fun PlaylistSearchRow(playlist: PlaylistSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = playlist.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(
+                        R.string.search_playlist_subtitle,
+                        playlist.trackCount,
+                        formatDuration(playlist.totalDurationMs)
+                    ),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun FolderSearchRow(folder: FolderSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = folder.name, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(R.string.search_folder_subtitle, folder.path, folder.trackCount),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun AlbumSearchRow(album: AlbumSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = album.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(R.string.search_album_subtitle, album.artist, album.trackCount),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun ArtistSearchRow(artist: ArtistSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = artist.name, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(R.string.search_artist_subtitle, artist.albumCount, artist.trackCount),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun GenreSearchRow(genre: GenreSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = genre.name, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(R.string.search_genre_subtitle, genre.trackCount),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun LongformSearchRow(item: LongformItem, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = item.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(
+                    text = stringResource(
+                        R.string.search_longform_subtitle,
+                        item.category.name,
+                        formatDuration(item.durationMs)
+                    ),
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+        )
+    }
+}
+
+@Composable
+private fun VideoSearchRow(video: VideoSummary, onClick: () -> Unit) {
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .clickable(onClick = onClick),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        ListItem(
+            headlineContent = {
+                Text(text = video.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+            },
+            supportingContent = {
+                Text(text = formatDuration(video.durationMs))
+            }
+        )
+    }
+}
+
+@Composable
+private fun LibraryTopBar(
+    onOpenDrawer: () -> Unit,
+    onSearch: () -> Unit,
+    onOpenThemeStudio: () -> Unit,
+    onOpenSettings: () -> Unit
+) {
+    CenterAlignedTopAppBar(
+        title = {
+            Column(horizontalAlignment = Alignment.CenterHorizontally) {
+                Text(text = stringResource(R.string.app_name), style = MaterialTheme.typography.titleLarge)
+                Text(
+                    text = stringResource(R.string.app_tagline),
+                    style = MaterialTheme.typography.labelMedium
+                )
+            }
+        },
+        navigationIcon = {
+            IconButton(onClick = onOpenDrawer) {
+                Icon(imageVector = Icons.Filled.Menu, contentDescription = stringResource(R.string.drawer_toggle_content_description))
+            }
+        },
+        actions = {
+            IconButton(onClick = onSearch) {
+                Icon(imageVector = Icons.Outlined.Search, contentDescription = stringResource(R.string.search_content_description))
+            }
+            IconButton(onClick = onOpenThemeStudio) {
+                Icon(imageVector = Icons.Outlined.Palette, contentDescription = stringResource(R.string.theme_studio_content_description))
+            }
+            IconButton(onClick = onOpenSettings) {
+                Icon(imageVector = Icons.Outlined.Settings, contentDescription = stringResource(R.string.settings_content_description))
+            }
+        }
+    )
+}
+
+@Composable
+private fun DrawerContent(
+    destinations: List<DrawerDestination>,
+    selected: DrawerDestinationId,
+    onDestinationSelected: (DrawerDestinationId) -> Unit
+) {
+    Column(modifier = Modifier.padding(vertical = 24.dp)) {
+        Text(
+            text = stringResource(R.string.drawer_title),
+            style = MaterialTheme.typography.titleMedium,
+            modifier = Modifier.padding(horizontal = 24.dp, vertical = 8.dp)
+        )
+        destinations.forEach { destination ->
+            NavigationDrawerItem(
+                label = { Text(text = stringResource(destination.titleRes)) },
+                selected = destination.id == selected,
+                onClick = { onDestinationSelected(destination.id) },
+                icon = { Icon(imageVector = destination.icon, contentDescription = null) },
+                modifier = Modifier.padding(NavigationDrawerItemDefaults.ItemPadding)
+            )
+        }
+    }
+}
+
+private val DrawerDestination.icon: ImageVector
+    get() = when (id) {
+        DrawerDestinationId.Library -> Icons.Outlined.LibraryMusic
+        DrawerDestinationId.Equalizer -> Icons.Outlined.Equalizer
+        DrawerDestinationId.SleepTimer -> Icons.Outlined.Timer
+        DrawerDestinationId.ThemeStudio -> Icons.Outlined.Palette
+        DrawerDestinationId.Widgets -> Icons.Outlined.Widget
+        DrawerDestinationId.ScanImport -> Icons.Outlined.QueueMusic
+        DrawerDestinationId.Settings -> Icons.Outlined.Settings
+        DrawerDestinationId.Help -> Icons.Outlined.HelpOutline
+    }
+
+@Composable
+private fun LibraryContent(
+    homeState: HomeUiState,
+    playerState: PlayerUiState,
+    equalizerState: EqualizerUiState,
+    lyricsState: LyricsUiState,
+    themeState: ThemeUiState,
+    tagEditorState: TagEditorUiState,
+    onTogglePlayPause: () -> Unit,
+    onSeekTo: (Long) -> Unit,
+    onTabSelected: (HomeTab) -> Unit,
+    onSongSelected: (String) -> Unit,
+    onShowLyrics: () -> Unit,
+    onShowTagEditor: () -> Unit,
+    onEqualizerEnabledChange: (Boolean) -> Unit,
+    onBandLevelChange: (Int, Int) -> Unit,
+    onPresetSelected: (Int) -> Unit,
+    onBassBoostChange: (Int) -> Unit,
+    onVirtualizerChange: (Int) -> Unit,
+    onReverbSelected: (Short) -> Unit,
+    onLyricsDraftChange: (String) -> Unit,
+    onLyricsSave: () -> Unit,
+    onLyricsClear: () -> Unit,
+    onSampleLyrics: () -> Unit,
+    onSelectThemeOption: (Int) -> Unit,
+    onToggleDarkTheme: (Boolean) -> Unit,
+    onUpdateTagTitle: (String) -> Unit,
+    onUpdateTagArtist: (String) -> Unit,
+    onUpdateTagAlbum: (String) -> Unit,
+    onSaveTags: () -> Unit,
+    onResetTags: () -> Unit,
+    onSelectLongformFilter: (LongformFilter) -> Unit,
+    contentPadding: PaddingValues
+) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(contentPadding)
+    ) {
+        ScrollableTabRow(
+            selectedTabIndex = homeState.selectedTab.ordinal,
+            edgePadding = 16.dp
+        ) {
+            HomeTab.entries.forEach { tab ->
+                Tab(
+                    selected = tab == homeState.selectedTab,
+                    onClick = { onTabSelected(tab) },
+                    text = { Text(text = stringResource(tab.titleRes)) }
+                )
+            }
+        }
+
+        when (homeState.selectedTab) {
+            HomeTab.Songs -> SongsTab(
+                songs = homeState.songs,
+                playerState = playerState,
+                onSongSelected = onSongSelected,
+                onPlayAllSongs = onPlayAllSongs,
+                onShuffleAllSongs = onShuffleAllSongs,
+                onTogglePlayPause = onTogglePlayPause,
+                onSeekTo = onSeekTo,
+                onShowLyrics = onShowLyrics,
+                onShowTagEditor = onShowTagEditor,
+                onShareCurrentSong = onShareCurrentSong,
+                onShareSong = onShareSong,
+                sortState = songSort,
+                onSortFieldSelected = onSongSortFieldSelected,
+                onSortDirectionToggle = onSongSortDirectionToggle
+            )
+            HomeTab.Playlists -> PlaylistsTab(homeState.playlists)
+            HomeTab.Folders -> FoldersTab(homeState.folders)
+            HomeTab.Albums -> AlbumsTab(
+                albums = homeState.albums,
+                sortDirection = albumSortDirection,
+                onToggleSortDirection = onAlbumSortToggle
+            )
+            HomeTab.Artists -> ArtistsTab(
+                artists = homeState.artists,
+                sortDirection = artistSortDirection,
+                onToggleSortDirection = onArtistSortToggle
+            )
+            HomeTab.Genres -> GenresTab(homeState.genres)
+            HomeTab.Longform -> LongformTab(
+                state = homeState,
+                onFilterSelected = onSelectLongformFilter,
+                onPlayNow = onSongSelected
+            )
+            HomeTab.Videos -> VideosTab(homeState.videos)
+        }
+    }
+}
+
+@Composable
+private fun SongsTab(
+    songs: List<SongSummary>,
+    playerState: PlayerUiState,
+    onSongSelected: (String) -> Unit,
+    onPlayAllSongs: () -> Unit,
+    onShuffleAllSongs: () -> Unit,
+    onTogglePlayPause: () -> Unit,
+    onSeekTo: (Long) -> Unit,
+    onShowLyrics: () -> Unit,
+    onShowTagEditor: () -> Unit,
+    onShareCurrentSong: () -> Unit,
+    onShareSong: (String) -> Unit,
+    sortState: SongSortState,
+    onSortFieldSelected: (SongSortField) -> Unit,
+    onSortDirectionToggle: () -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            NowPlayingCard(
+                state = playerState,
+                onTogglePlayPause = onTogglePlayPause,
+                onSeekTo = onSeekTo,
+                onShowLyrics = onShowLyrics,
+                onShowTagEditor = onShowTagEditor,
+                onShare = onShareCurrentSong
+            )
+            Spacer(modifier = Modifier.height(12.dp))
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.spacedBy(12.dp)
+            ) {
+                FilledTonalButton(
+                    onClick = onShuffleAllSongs,
+                    modifier = Modifier
+                        .weight(1f)
+                        .height(56.dp)
+                ) {
+                    Text(text = stringResource(R.string.songs_shuffle_all_button))
+                }
+                Button(
+                    onClick = onPlayAllSongs,
+                    modifier = Modifier
+                        .weight(1f)
+                        .height(56.dp)
+                ) {
+                    Text(text = stringResource(R.string.songs_play_all_button))
+                }
+            }
+            Text(
+                text = stringResource(R.string.songs_tab_count, songs.size),
+                style = MaterialTheme.typography.labelMedium,
+                modifier = Modifier.padding(top = 16.dp)
+            )
+            SongsSortRow(
+                sortState = sortState,
+                onSortFieldSelected = onSortFieldSelected,
+                onSortDirectionToggle = onSortDirectionToggle,
+                modifier = Modifier.padding(top = 12.dp)
+            )
+        }
+        items(songs) { song ->
+            val isCurrent = song.id == playerState.currentSongId
+            val cardColors = if (isCurrent) {
+                CardDefaults.cardColors(
+                    containerColor = MaterialTheme.colorScheme.primaryContainer,
+                    contentColor = MaterialTheme.colorScheme.onPrimaryContainer
+                )
+            } else {
+                CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+            }
+            Card(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .clickable { onSongSelected(song.id) },
+                colors = cardColors
+            ) {
+                ListItem(
+                    leadingContent = if (isCurrent) {
+                        {
+                            val indicatorDescription = stringResource(
+                                if (playerState.isPlaying) {
+                                    R.string.songs_now_playing_indicator_playing
+                                } else {
+                                    R.string.songs_now_playing_indicator_paused
+                                }
+                            )
+                            Icon(
+                                imageVector = if (playerState.isPlaying) {
+                                    Icons.Outlined.Equalizer
+                                } else {
+                                    Icons.Outlined.PlayArrow
+                                },
+                                contentDescription = indicatorDescription
+                            )
+                        }
+                    } else {
+                        null
+                    },
+                    headlineContent = {
+                        Text(text = song.title, maxLines = 1, overflow = TextOverflow.Ellipsis)
+                    },
+                    supportingContent = {
+                        Text(
+                            text = stringResource(R.string.song_row_subtitle, song.artist, song.album),
+                            maxLines = 1,
+                            overflow = TextOverflow.Ellipsis
+                        )
+                    },
+                    trailingContent = {
+                        Row(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalAlignment = Alignment.CenterVertically) {
+                            Text(text = formatDuration(song.durationMs))
+                            IconButton(onClick = { onShareSong(song.id) }) {
+                                Icon(
+                                    imageVector = Icons.Outlined.Share,
+                                    contentDescription = stringResource(
+                                        R.string.share_song_row_content_description,
+                                        song.title
+                                    )
+                                )
+                            }
+                        }
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun SongsSortRow(
+    sortState: SongSortState,
+    onSortFieldSelected: (SongSortField) -> Unit,
+    onSortDirectionToggle: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    var menuExpanded by remember { mutableStateOf(false) }
+    val directionIcon = if (sortState.direction == SortDirection.Ascending) {
+        Icons.Outlined.ArrowUpward
+    } else {
+        Icons.Outlined.ArrowDownward
+    }
+    val directionContentDescription = songSortDirectionContentDescription(sortState)
+    Row(
+        modifier = modifier.fillMaxWidth(),
+        horizontalArrangement = Arrangement.spacedBy(12.dp),
+        verticalAlignment = Alignment.CenterVertically
+    ) {
+        Text(
+            text = stringResource(R.string.songs_sort_label),
+            style = MaterialTheme.typography.labelMedium
+        )
+        Box {
+            AssistChip(
+                onClick = { menuExpanded = true },
+                label = { Text(text = stringResource(sortState.field.labelRes)) },
+                leadingIcon = { Icon(imageVector = Icons.Outlined.Sort, contentDescription = null) }
+            )
+            DropdownMenu(expanded = menuExpanded, onDismissRequest = { menuExpanded = false }) {
+                SongSortField.entries.forEach { field ->
+                    DropdownMenuItem(
+                        text = { Text(text = stringResource(field.labelRes)) },
+                        onClick = {
+                            menuExpanded = false
+                            onSortFieldSelected(field)
+                        },
+                        trailingIcon = {
+                            if (field == sortState.field) {
+                                Icon(imageVector = Icons.Outlined.Check, contentDescription = null)
+                            }
+                        }
+                    )
+                }
+            }
+        }
+        AssistChip(
+            onClick = onSortDirectionToggle,
+            label = { Text(text = stringResource(sortState.direction.labelRes)) },
+            leadingIcon = { Icon(imageVector = directionIcon, contentDescription = null) },
+            modifier = Modifier.semantics { this.contentDescription = directionContentDescription }
+        )
+    }
+}
+
+@Composable
+private fun songSortDirectionContentDescription(sortState: SongSortState): String {
+    val resId = when (sortState.field) {
+        SongSortField.Title -> if (sortState.direction == SortDirection.Ascending) {
+            R.string.songs_sort_direction_title_ascending
+        } else {
+            R.string.songs_sort_direction_title_descending
+        }
+        SongSortField.Added -> if (sortState.direction == SortDirection.Descending) {
+            R.string.songs_sort_direction_added_descending
+        } else {
+            R.string.songs_sort_direction_added_ascending
+        }
+        SongSortField.Duration -> if (sortState.direction == SortDirection.Ascending) {
+            R.string.songs_sort_direction_duration_ascending
+        } else {
+            R.string.songs_sort_direction_duration_descending
+        }
+    }
+    return stringResource(resId)
+}
+
+@Composable
+private fun PlaylistsTab(playlists: List<PlaylistSummary>) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Text(
+                text = stringResource(R.string.playlists_tab_count, playlists.size),
+                style = MaterialTheme.typography.labelMedium,
+                modifier = Modifier.padding(bottom = 4.dp)
+            )
+        }
+        items(playlists) { playlist ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    headlineContent = { Text(text = playlist.title) },
+                    supportingContent = {
+                        Text(
+                            text = stringResource(R.string.playlist_row_subtitle, playlist.trackCount, formatDuration(playlist.totalDurationMs))
+                        )
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun FoldersTab(folders: List<FolderSummary>) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Text(
+                text = stringResource(R.string.folders_tab_count, folders.size),
+                style = MaterialTheme.typography.labelMedium,
+                modifier = Modifier.padding(bottom = 4.dp)
+            )
+        }
+        items(folders) { folder ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    headlineContent = { Text(text = folder.name) },
+                    supportingContent = {
+                        Text(text = folder.path)
+                    },
+                    trailingContent = {
+                        Text(text = stringResource(R.string.folder_row_track_count, folder.trackCount))
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun AlbumsTab(
+    albums: List<AlbumSummary>,
+    sortDirection: SortDirection,
+    onToggleSortDirection: () -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Row(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .padding(bottom = 4.dp),
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text(
+                    text = stringResource(R.string.albums_tab_count, albums.size),
+                    style = MaterialTheme.typography.labelMedium
+                )
+                val icon = if (sortDirection == SortDirection.Ascending) {
+                    Icons.Outlined.ArrowUpward
+                } else {
+                    Icons.Outlined.ArrowDownward
+                }
+                val contentDescription = stringResource(
+                    if (sortDirection == SortDirection.Ascending) {
+                        R.string.albums_sort_direction_ascending
+                    } else {
+                        R.string.albums_sort_direction_descending
+                    }
+                )
+                AssistChip(
+                    onClick = onToggleSortDirection,
+                    label = { Text(text = stringResource(sortDirection.labelRes)) },
+                    leadingIcon = { Icon(imageVector = icon, contentDescription = null) },
+                    modifier = Modifier.semantics { this.contentDescription = contentDescription }
+                )
+            }
+        }
+        items(albums) { album ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    leadingContent = {
+                        Icon(imageVector = Icons.Outlined.Album, contentDescription = null)
+                    },
+                    headlineContent = { Text(text = album.title) },
+                    supportingContent = {
+                        Text(text = album.artist)
+                    },
+                    trailingContent = {
+                        Text(text = stringResource(R.string.album_row_track_count, album.trackCount))
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun ArtistsTab(
+    artists: List<ArtistSummary>,
+    sortDirection: SortDirection,
+    onToggleSortDirection: () -> Unit
+) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Row(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .padding(bottom = 4.dp),
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text(
+                    text = stringResource(R.string.artists_tab_count, artists.size),
+                    style = MaterialTheme.typography.labelMedium
+                )
+                val icon = if (sortDirection == SortDirection.Ascending) {
+                    Icons.Outlined.ArrowUpward
+                } else {
+                    Icons.Outlined.ArrowDownward
+                }
+                val contentDescription = stringResource(
+                    if (sortDirection == SortDirection.Ascending) {
+                        R.string.artists_sort_direction_ascending
+                    } else {
+                        R.string.artists_sort_direction_descending
+                    }
+                )
+                AssistChip(
+                    onClick = onToggleSortDirection,
+                    label = { Text(text = stringResource(sortDirection.labelRes)) },
+                    leadingIcon = { Icon(imageVector = icon, contentDescription = null) },
+                    modifier = Modifier.semantics { this.contentDescription = contentDescription }
+                )
+            }
+        }
+        items(artists) { artist ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    headlineContent = { Text(text = artist.name) },
+                    supportingContent = {
+                        Text(text = stringResource(R.string.artist_row_detail, artist.albumCount, artist.trackCount))
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun GenresTab(genres: List<GenreSummary>) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Text(
+                text = stringResource(R.string.genres_tab_count, genres.size),
+                style = MaterialTheme.typography.labelMedium,
+                modifier = Modifier.padding(bottom = 4.dp)
+            )
+        }
+        items(genres) { genre ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    headlineContent = { Text(text = genre.name) },
+                    trailingContent = {
+                        Text(text = stringResource(R.string.genre_row_track_count, genre.trackCount))
+                    }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun LongformTab(
+    state: HomeUiState,
+    onFilterSelected: (LongformFilter) -> Unit,
+    onPlayNow: (String) -> Unit
+) {
+    val defaultSongId = state.songs.firstOrNull()?.id
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(horizontal = 24.dp, vertical = 16.dp)
+    ) {
+        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
+            LongformFilter.entries.forEach { filter ->
+                FilterChip(
+                    selected = state.longformFilter == filter,
+                    onClick = { onFilterSelected(filter) },
+                    label = { Text(text = stringResource(filter.labelRes)) }
+                )
+            }
+        }
+        Spacer(modifier = Modifier.height(16.dp))
+        LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
+            items(state.filteredLongformItems) { item ->
+                ElevatedCard(
+                    onClick = { defaultSongId?.let(onPlayNow) },
+                    modifier = Modifier.fillMaxWidth(),
+                    enabled = defaultSongId != null
+                ) {
+                    ListItem(
+                        headlineContent = { Text(text = item.title) },
+                        supportingContent = {
+                            Text(text = stringResource(R.string.longform_row_source, item.source))
+                        },
+                        trailingContent = {
+                            Text(text = formatDuration(item.durationMs))
+                        }
+                    )
+                }
+            }
+        }
+    }
+}
+
+@Composable
+private fun VideosTab(videos: List<VideoSummary>) {
+    LazyColumn(
+        modifier = Modifier.fillMaxSize(),
+        contentPadding = PaddingValues(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        item {
+            Text(
+                text = stringResource(R.string.videos_tab_count, videos.size),
+                style = MaterialTheme.typography.labelMedium,
+                modifier = Modifier.padding(bottom = 4.dp)
+            )
+        }
+        items(videos) { video ->
+            ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+                ListItem(
+                    leadingContent = {
+                        Icon(imageVector = Icons.Outlined.VideoLibrary, contentDescription = null)
+                    },
+                    headlineContent = { Text(text = video.title) },
+                    trailingContent = { Text(text = formatDuration(video.durationMs)) }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun NowPlayingCard(
+    state: PlayerUiState,
+    onTogglePlayPause: () -> Unit,
+    onSeekTo: (Long) -> Unit,
+    onShowLyrics: () -> Unit,
+    onShowTagEditor: () -> Unit,
+    onShare: () -> Unit
+) {
+    ElevatedCard(modifier = Modifier.fillMaxWidth()) {
+        Column(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(20.dp),
+            verticalArrangement = Arrangement.spacedBy(16.dp)
+        ) {
+            Text(text = stringResource(R.string.now_playing_title), style = MaterialTheme.typography.titleMedium)
+            Text(text = state.title, style = MaterialTheme.typography.headlineSmall)
+            Text(text = stringResource(R.string.now_playing_artist_album, state.artist, state.album))
+            PlaybackSlider(
+                state = state,
+                onSeekTo = onSeekTo,
+                modifier = Modifier.fillMaxWidth()
+            )
+            Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
+                Button(onClick = onTogglePlayPause) {
+                    Text(text = if (state.isPlaying) stringResource(R.string.pause_action) else stringResource(R.string.play_action))
+                }
+                AssistChip(onClick = onShowLyrics, label = { Text(text = stringResource(R.string.lyrics_tab)) })
+                AssistChip(onClick = onShowTagEditor, label = { Text(text = stringResource(R.string.tags_tab)) })
+                AssistChip(
+                    onClick = onShare,
+                    label = { Text(text = stringResource(R.string.share_song_action)) },
+                    leadingIcon = { Icon(imageVector = Icons.Outlined.Share, contentDescription = null) },
+                    modifier = Modifier.semantics { contentDescription = stringResource(R.string.share_song_content_description) }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun MiniPlayer(
+    state: PlayerUiState,
+    onTogglePlayPause: () -> Unit,
+    onPlayNext: () -> Unit,
+    onPlayPrevious: () -> Unit,
+    onOpenNowPlaying: () -> Unit,
+    onShowQueue: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Surface(tonalElevation = 3.dp, modifier = modifier.fillMaxWidth()) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .clickable { onOpenNowPlaying() }
+                .padding(horizontal = 20.dp, vertical = 12.dp),
+            verticalAlignment = Alignment.CenterVertically,
+            horizontalArrangement = Arrangement.spacedBy(16.dp)
+        ) {
+            Column(modifier = Modifier.weight(1f)) {
+                Text(text = state.title, style = MaterialTheme.typography.bodyLarge, maxLines = 1, overflow = TextOverflow.Ellipsis)
+                Text(
+                    text = stringResource(R.string.now_playing_artist_album, state.artist, state.album),
+                    style = MaterialTheme.typography.bodySmall,
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+            }
+            IconButton(onClick = onPlayPrevious) {
+                Icon(imageVector = Icons.Outlined.SkipPrevious, contentDescription = stringResource(R.string.mini_player_previous_content_description))
+            }
+            IconButton(onClick = onTogglePlayPause) {
+                val icon = if (state.isPlaying) Icons.Outlined.Pause else Icons.Outlined.PlayArrow
+                val description = if (state.isPlaying) {
+                    stringResource(R.string.pause_content_description)
+                } else {
+                    stringResource(R.string.play_content_description)
+                }
+                Icon(imageVector = icon, contentDescription = description)
+            }
+            IconButton(onClick = onPlayNext) {
+                Icon(imageVector = Icons.Outlined.SkipNext, contentDescription = stringResource(R.string.mini_player_next_content_description))
+            }
+            IconButton(onClick = onShowQueue) {
+                Icon(imageVector = Icons.Outlined.QueueMusic, contentDescription = stringResource(R.string.mini_player_queue_content_description))
+            }
+        }
+    }
+}
+
+@OptIn(ExperimentalMaterialApi::class)
+@Composable
+private fun QueueSheet(
+    queueState: QueueUiState,
+    onSongSelected: (String) -> Unit,
+    onRemoveFromQueue: (String) -> Unit,
+    modifier: Modifier = Modifier
+) {
+    LazyColumn(
+        modifier = modifier.padding(horizontal = 24.dp),
+        verticalArrangement = Arrangement.spacedBy(8.dp)
+    ) {
+        item {
+            Text(
+                text = stringResource(R.string.queue_title),
+                style = MaterialTheme.typography.titleLarge,
+                modifier = Modifier.padding(top = 16.dp, bottom = 8.dp)
+            )
+        }
+        queueState.nowPlaying?.let { nowPlaying ->
+            item {
+                Text(text = stringResource(R.string.queue_now_playing), style = MaterialTheme.typography.titleMedium)
+                ListItem(
+                    headlineContent = { Text(text = nowPlaying.title) },
+                    supportingContent = {
+                        Text(text = stringResource(R.string.song_row_subtitle, nowPlaying.artist, nowPlaying.album))
+                    },
+                    trailingContent = { Text(text = formatDuration(nowPlaying.durationMs)) }
+                )
+                Divider(modifier = Modifier.padding(vertical = 12.dp))
+            }
+        }
+        if (queueState.history.isNotEmpty()) {
+            item {
+                Text(text = stringResource(R.string.queue_history_header), style = MaterialTheme.typography.titleSmall)
+            }
+            items(queueState.history, key = { it.id }) { song ->
+                ListItem(
+                    headlineContent = { Text(text = song.title) },
+                    supportingContent = { Text(text = song.artist) },
+                    trailingContent = { Text(text = formatDuration(song.durationMs)) }
+                )
+            }
+            item { Divider(modifier = Modifier.padding(vertical = 12.dp)) }
+        }
+        item {
+            Text(text = stringResource(R.string.queue_up_next_header), style = MaterialTheme.typography.titleSmall)
+        }
+        if (queueState.upNext.isEmpty()) {
+            item {
+                Text(
+                    text = stringResource(R.string.queue_empty_up_next),
+                    style = MaterialTheme.typography.bodyMedium,
+                    modifier = Modifier.padding(vertical = 12.dp)
+                )
+            }
+        } else {
+            items(queueState.upNext, key = { it.id }) { song ->
+                Column {
+                    QueueUpNextRow(
+                        song = song,
+                        onSongSelected = onSongSelected,
+                        onRemoveFromQueue = onRemoveFromQueue
+                    )
+                    Divider()
+                }
+            }
+        }
+    }
+}
+
+@OptIn(ExperimentalMaterialApi::class)
+@Composable
+private fun QueueUpNextRow(
+    song: SongSummary,
+    onSongSelected: (String) -> Unit,
+    onRemoveFromQueue: (String) -> Unit
+) {
+    val dismissState = rememberDismissState { value ->
+        if (value == DismissValue.DismissedToEnd || value == DismissValue.DismissedToStart) {
+            onRemoveFromQueue(song.id)
+            true
+        } else {
+            false
+        }
+    }
+    SwipeToDismiss(
+        state = dismissState,
+        directions = setOf(DismissDirection.StartToEnd, DismissDirection.EndToStart),
+        background = { QueueDismissBackground(dismissState = dismissState) },
+        dismissContent = {
+            ListItem(
+                modifier = Modifier.clickable { onSongSelected(song.id) },
+                headlineContent = { Text(text = song.title) },
+                supportingContent = { Text(text = song.artist) },
+                trailingContent = {
+                    Row(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalAlignment = Alignment.CenterVertically) {
+                        Text(text = formatDuration(song.durationMs))
+                        IconButton(onClick = { onRemoveFromQueue(song.id) }) {
+                            Icon(
+                                imageVector = Icons.Outlined.Delete,
+                                contentDescription = stringResource(R.string.queue_remove_content_description)
+                            )
+                        }
+                    }
+                }
+            )
+        }
+    )
+}
+
+@OptIn(ExperimentalMaterialApi::class)
+@Composable
+private fun QueueDismissBackground(dismissState: DismissState) {
+    val backgroundColor = MaterialTheme.colorScheme.errorContainer
+    val contentColor = MaterialTheme.colorScheme.onErrorContainer
+    val alignment = when (dismissState.dismissDirection) {
+        DismissDirection.StartToEnd -> Alignment.CenterStart
+        DismissDirection.EndToStart -> Alignment.CenterEnd
+        else -> Alignment.CenterEnd
+    }
+    Surface(
+        color = backgroundColor,
+        contentColor = contentColor,
+        modifier = Modifier
+            .fillMaxWidth()
+            .height(72.dp)
+            .padding(horizontal = 12.dp),
+        shape = MaterialTheme.shapes.medium
+    ) {
+        Box(contentAlignment = alignment, modifier = Modifier.fillMaxSize()) {
+            Row(
+                verticalAlignment = Alignment.CenterVertically,
+                horizontalArrangement = Arrangement.spacedBy(12.dp),
+                modifier = Modifier.padding(horizontal = 20.dp)
+            ) {
+                Icon(imageVector = Icons.Outlined.Delete, contentDescription = null)
+                Text(text = stringResource(R.string.queue_remove_label), style = MaterialTheme.typography.bodyMedium)
+            }
+        }
+    }
+}
+
+@Composable
+private fun NowPlayingScreen(
+    state: PlayerUiState,
+    onTogglePlayPause: () -> Unit,
+    onSeekTo: (Long) -> Unit,
+    onShowLyrics: () -> Unit,
+    onShowTagEditor: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(
+        modifier = modifier
+            .padding(horizontal = 24.dp, vertical = 16.dp),
+        verticalArrangement = Arrangement.spacedBy(20.dp),
+        horizontalAlignment = Alignment.CenterHorizontally
+    ) {
+        Text(text = stringResource(R.string.now_playing_title), style = MaterialTheme.typography.titleLarge)
+        Text(text = state.title, style = MaterialTheme.typography.headlineMedium, fontWeight = FontWeight.SemiBold)
+        Text(text = stringResource(R.string.now_playing_artist_album, state.artist, state.album))
+        PlaybackSlider(state = state, onSeekTo = onSeekTo, modifier = Modifier.fillMaxWidth())
+        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
+            Button(onClick = onTogglePlayPause) {
+                Text(text = if (state.isPlaying) stringResource(R.string.pause_action) else stringResource(R.string.play_action))
+            }
+            TextButton(onClick = onShowLyrics) {
+                Text(text = stringResource(R.string.lyrics_tab))
+            }
+            TextButton(onClick = onShowTagEditor) {
+                Text(text = stringResource(R.string.tags_tab))
+            }
+        }
+    }
+}
+
+@Composable
+private fun PlaceholderScreen(
+    @StringRes titleRes: Int,
+    @StringRes messageRes: Int,
+    modifier: Modifier = Modifier
+) {
+    Box(modifier = modifier, contentAlignment = Alignment.Center) {
+        Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(8.dp)) {
+            Text(text = stringResource(titleRes), style = MaterialTheme.typography.titleLarge)
+            Text(text = stringResource(messageRes), style = MaterialTheme.typography.bodyMedium)
+        }
+    }
+}
+
+@Composable
+private fun PlaybackSlider(
+    state: PlayerUiState,
+    onSeekTo: (Long) -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(modifier = modifier) {
+        Slider(
+            value = if (state.durationMs == 0L) 0f else state.positionMs.toFloat() / state.durationMs.toFloat(),
+            onValueChange = { fraction ->
+                if (state.durationMs > 0) {
+                    onSeekTo((state.durationMs * fraction).toLong())
+                }
+            }
+        )
+        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
+            Text(text = state.positionText, style = MaterialTheme.typography.labelSmall)
+            Text(text = state.durationText, style = MaterialTheme.typography.labelSmall)
+        }
+    }
+}
+
+@Composable
+private fun EqualizerScreen(
+    state: EqualizerUiState,
+    onEqualizerEnabledChange: (Boolean) -> Unit,
+    onBandLevelChange: (Int, Int) -> Unit,
+    onPresetSelected: (Int) -> Unit,
+    onBassBoostChange: (Int) -> Unit,
+    onVirtualizerChange: (Int) -> Unit,
+    onReverbSelected: (Short) -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(
+        modifier = modifier.verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.spacedBy(16.dp)
+    ) {
+        Text(text = stringResource(R.string.equalizer_tab), style = MaterialTheme.typography.titleLarge)
+        if (!state.isAvailable) {
+            Text(text = stringResource(R.string.equalizer_not_available))
+            return
+        }
+        Row(verticalAlignment = Alignment.CenterVertically) {
+            Text(text = stringResource(R.string.equalizer_enable_label), modifier = Modifier.weight(1f))
+            ElevatedFilterChip(selected = state.isEnabled, onClick = { onEqualizerEnabledChange(!state.isEnabled) }, label = {
+                Text(text = if (state.isEnabled) stringResource(R.string.pause_action) else stringResource(R.string.play_action))
+            })
+        }
+        Text(text = stringResource(R.string.equalizer_preset_label), style = MaterialTheme.typography.titleMedium)
+        if (state.presets.isEmpty()) {
+            Text(text = stringResource(R.string.equalizer_no_presets))
+        } else {
+            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
+                state.presets.forEachIndexed { index, preset ->
+                    FilterChip(
+                        selected = state.selectedPresetIndex == index,
+                        onClick = { onPresetSelected(index) },
+                        label = { Text(text = preset) }
+                    )
+                }
+            }
+        }
+        state.bands.forEach { band ->
+            Column {
+                Text(text = band.label)
+                Slider(
+                    value = band.levelMillibels.toFloat(),
+                    onValueChange = { onBandLevelChange(band.index, it.toInt()) },
+                    valueRange = band.minLevelMillibels.toFloat()..band.maxLevelMillibels.toFloat()
+                )
+            }
+        }
+        if (state.isBassBoostSupported) {
+            Text(text = stringResource(R.string.equalizer_bass_boost_label), style = MaterialTheme.typography.titleMedium)
+            Slider(value = state.bassBoostStrength.toFloat(), onValueChange = { onBassBoostChange(it.toInt()) }, valueRange = 0f..1000f)
+        }
+        if (state.isVirtualizerSupported) {
+            Text(text = stringResource(R.string.equalizer_virtualizer_label), style = MaterialTheme.typography.titleMedium)
+            Slider(value = state.virtualizerStrength.toFloat(), onValueChange = { onVirtualizerChange(it.toInt()) }, valueRange = 0f..1000f)
+        }
+        Text(text = stringResource(R.string.equalizer_reverb_label), style = MaterialTheme.typography.titleMedium)
+        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
+            state.reverbOptions.forEach { option ->
+                FilterChip(
+                    selected = state.selectedReverbPreset == option.preset,
+                    onClick = { onReverbSelected(option.preset) },
+                    label = { Text(text = option.label) }
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun LyricsScreen(
+    state: LyricsUiState,
+    onDraftChange: (String) -> Unit,
+    onSave: () -> Unit,
+    onClear: () -> Unit,
+    onLoadSample: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(
+        modifier = modifier.verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        Text(text = stringResource(R.string.lyrics_tab), style = MaterialTheme.typography.titleLarge)
+        androidx.compose.material3.OutlinedTextField(
+            value = state.draftLyrics,
+            onValueChange = onDraftChange,
+            modifier = Modifier
+                .fillMaxWidth()
+                .height(200.dp),
+            label = { Text(text = stringResource(R.string.lyrics_input_label)) },
+            placeholder = { Text(text = stringResource(R.string.lyrics_input_hint)) }
+        )
+        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
+            Button(onClick = onSave, enabled = state.isSaveEnabled) { Text(text = stringResource(R.string.lyrics_save_button)) }
+            TextButton(onClick = onClear) { Text(text = stringResource(R.string.lyrics_clear_button)) }
+            TextButton(onClick = onLoadSample) { Text(text = stringResource(R.string.lyrics_load_sample_button)) }
+        }
+        if (state.currentLyrics.isBlank()) {
+            Text(text = stringResource(R.string.lyrics_empty_state))
+        } else {
+            Text(text = state.currentLyrics)
+        }
+        state.statusMessage?.let {
+            Text(text = it, style = MaterialTheme.typography.labelMedium)
+        }
+    }
+}
+
+@Composable
+private fun ThemeScreen(
+    state: ThemeUiState,
+    onSelectOption: (Int) -> Unit,
+    onToggleDarkTheme: (Boolean) -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(
+        modifier = modifier.verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        Text(text = stringResource(R.string.themes_tab), style = MaterialTheme.typography.titleLarge)
+        state.options.forEachIndexed { index, option ->
+            ElevatedCard(
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .clickable { onSelectOption(index) },
+                colors = CardDefaults.cardColors(containerColor = option.darkColorScheme.surface)
+            ) {
+                Column(modifier = Modifier.padding(16.dp)) {
+                    Text(text = stringResource(option.labelRes), style = MaterialTheme.typography.titleMedium)
+                    Text(text = stringResource(R.string.theme_preview_hint))
+                }
+            }
+        }
+        Row(verticalAlignment = Alignment.CenterVertically) {
+            Text(text = stringResource(R.string.theme_dark_mode_label), modifier = Modifier.weight(1f))
+            ElevatedFilterChip(selected = state.useDarkTheme, onClick = { onToggleDarkTheme(!state.useDarkTheme) }, label = {
+                Text(text = if (state.useDarkTheme) stringResource(R.string.dark_mode_on) else stringResource(R.string.dark_mode_off))
+            })
+        }
+    }
+}
+
+@Composable
+private fun TagEditorScreen(
+    state: TagEditorUiState,
+    onTitleChange: (String) -> Unit,
+    onArtistChange: (String) -> Unit,
+    onAlbumChange: (String) -> Unit,
+    onSave: () -> Unit,
+    onReset: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    Column(
+        modifier = modifier.verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.spacedBy(12.dp)
+    ) {
+        Text(text = stringResource(R.string.tags_tab), style = MaterialTheme.typography.titleLarge)
+        androidx.compose.material3.OutlinedTextField(
+            value = state.titleInput,
+            onValueChange = onTitleChange,
+            modifier = Modifier.fillMaxWidth(),
+            label = { Text(text = stringResource(R.string.tag_editor_title_label)) }
+        )
+        androidx.compose.material3.OutlinedTextField(
+            value = state.artistInput,
+            onValueChange = onArtistChange,
+            modifier = Modifier.fillMaxWidth(),
+            label = { Text(text = stringResource(R.string.tag_editor_artist_label)) }
+        )
+        androidx.compose.material3.OutlinedTextField(
+            value = state.albumInput,
+            onValueChange = onAlbumChange,
+            modifier = Modifier.fillMaxWidth(),
+            label = { Text(text = stringResource(R.string.tag_editor_album_label)) }
+        )
+        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
+            Button(onClick = onSave) { Text(text = stringResource(R.string.tag_editor_save_button)) }
+            TextButton(onClick = onReset) { Text(text = stringResource(R.string.tag_editor_reset_button)) }
+        }
+        state.statusMessage?.let {
+            Text(text = it, style = MaterialTheme.typography.labelMedium)
+        }
+    }
+}
+*** End of File
diff --git a/app/src/main/java/app/ember/studio/LibrarySorting.kt b/app/src/main/java/app/ember/studio/LibrarySorting.kt
new file mode 100644
index 0000000000000000000000000000000000000000..d4b79bf286d886f5f87740abdd20c30be001c508
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/LibrarySorting.kt
@@ -0,0 +1,47 @@
+package app.ember.studio
+
+import androidx.annotation.StringRes
+
+/** Sort fields available for the Songs tab. */
+enum class SongSortField(
+    @StringRes val labelRes: Int,
+    val defaultDirection: SortDirection
+) {
+    Title(labelRes = R.string.song_sort_field_title, defaultDirection = SortDirection.Ascending),
+    Added(labelRes = R.string.song_sort_field_added, defaultDirection = SortDirection.Descending),
+    Duration(labelRes = R.string.song_sort_field_duration, defaultDirection = SortDirection.Ascending)
+}
+
+/** Sort direction shared across library tabs. */
+enum class SortDirection(@StringRes val labelRes: Int) {
+    Ascending(labelRes = R.string.sort_direction_ascending),
+    Descending(labelRes = R.string.sort_direction_descending);
+
+    fun toggled(): SortDirection = if (this == Ascending) Descending else Ascending
+}
+
+/** State holder describing the current Songs tab sort configuration. */
+data class SongSortState(
+    val field: SongSortField = SongSortField.Title,
+    val direction: SortDirection = SongSortField.Title.defaultDirection
+)
+
+internal fun sortSongs(items: List<SongSummary>, sortState: SongSortState): List<SongSummary> {
+    val comparator = when (sortState.field) {
+        SongSortField.Title -> compareBy<SongSummary> { it.title.lowercase() }
+        SongSortField.Added -> compareBy<SongSummary> { it.addedTimestampMs }
+        SongSortField.Duration -> compareBy<SongSummary> { it.durationMs }
+    }
+    val sorted = items.sortedWith(comparator)
+    return if (sortState.direction == SortDirection.Ascending) sorted else sorted.reversed()
+}
+
+internal fun sortAlbums(items: List<AlbumSummary>, direction: SortDirection): List<AlbumSummary> {
+    val sorted = items.sortedBy { it.title.lowercase() }
+    return if (direction == SortDirection.Ascending) sorted else sorted.reversed()
+}
+
+internal fun sortArtists(items: List<ArtistSummary>, direction: SortDirection): List<ArtistSummary> {
+    val sorted = items.sortedBy { it.name.lowercase() }
+    return if (direction == SortDirection.Ascending) sorted else sorted.reversed()
+}
diff --git a/app/src/main/java/app/ember/studio/LongformHeuristics.kt b/app/src/main/java/app/ember/studio/LongformHeuristics.kt
new file mode 100644
index 0000000000000000000000000000000000000000..25cdaba5abfd3db0e31f4682e1166205741bed24
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/LongformHeuristics.kt
@@ -0,0 +1,28 @@
+package app.ember.studio
+
+import java.util.Locale
+
+internal const val LONGFORM_THRESHOLD_MS: Long = 20 * 60 * 1000L
+internal const val LONGFORM_AUDIOBOOK_DURATION_MS: Long = 2 * 60 * 60 * 1000L
+
+private val PODCAST_TOKENS = listOf("podcast", "episode", " ep", "show", "radio")
+private val AUDIOBOOK_TOKENS = listOf("audiobook", "chapter", "book", "volume", "vol", " ch")
+
+internal fun suggestLongformCategory(
+    title: String,
+    source: String,
+    existingCategory: LongformCategory,
+    durationMs: Long
+): LongformCategory {
+    if (existingCategory != LongformCategory.Unassigned) {
+        return existingCategory
+    }
+    val haystack = "$title $source".lowercase(Locale.US)
+    if (PODCAST_TOKENS.any { haystack.contains(it) }) {
+        return LongformCategory.Podcast
+    }
+    if (AUDIOBOOK_TOKENS.any { haystack.contains(it) } || durationMs >= LONGFORM_AUDIOBOOK_DURATION_MS) {
+        return LongformCategory.Audiobook
+    }
+    return LongformCategory.Unassigned
+}
diff --git a/app/src/main/java/app/ember/studio/MainActivity.kt b/app/src/main/java/app/ember/studio/MainActivity.kt
new file mode 100644
index 0000000000000000000000000000000000000000..e6f441e8a532fadf17c0e196da8b58048237f9bf
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/MainActivity.kt
@@ -0,0 +1,190 @@
+package app.ember.studio
+
+import android.Manifest
+import android.content.ActivityNotFoundException
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.net.Uri
+import android.os.Build
+import android.os.Bundle
+import android.widget.Toast
+import androidx.activity.ComponentActivity
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.compose.setContent
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.activity.viewModels
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.core.content.ContextCompat
+import app.ember.studio.PlayerViewModel.SongShareMessage
+
+class MainActivity : ComponentActivity() {
+    private val playerViewModel: PlayerViewModel by viewModels()
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+
+        val initialPermission = determineAudioPermission()
+        if (initialPermission == null || ContextCompat.checkSelfPermission(this, initialPermission) == PackageManager.PERMISSION_GRANTED) {
+            playerViewModel.onInitialPermissionGranted()
+        }
+
+        setContent {
+            val homeState by playerViewModel.homeState.collectAsStateWithLifecycle()
+            val playerState by playerViewModel.uiState.collectAsStateWithLifecycle()
+            val equalizerState by playerViewModel.equalizerState.collectAsStateWithLifecycle()
+            val lyricsState by playerViewModel.lyricsState.collectAsStateWithLifecycle()
+            val themeState by playerViewModel.themeState.collectAsStateWithLifecycle()
+            val tagEditorState by playerViewModel.tagEditorState.collectAsStateWithLifecycle()
+            val onboardingState by playerViewModel.onboardingState.collectAsStateWithLifecycle()
+
+            val audioPermission = determineAudioPermission()
+
+            val permissionLauncher = rememberLauncherForPermission { granted ->
+                playerViewModel.handlePermissionResult(granted)
+            }
+
+            val folderLauncher = rememberLauncherForFolder { uri ->
+                if (uri != null) {
+                    persistFolderAccess(uri)
+                    playerViewModel.onFolderSelected(uri)
+                } else {
+                    playerViewModel.onFolderSelectionCancelled()
+                }
+            }
+
+            EmberAudioPlayerApp(
+                homeState = homeState,
+                playerState = playerState,
+                equalizerState = equalizerState,
+                lyricsState = lyricsState,
+                themeState = themeState,
+                tagEditorState = tagEditorState,
+                onboardingState = onboardingState,
+                onTogglePlayPause = playerViewModel::togglePlayPause,
+                onSeekTo = playerViewModel::seekTo,
+                onEqualizerEnabledChange = playerViewModel::setEqualizerEnabled,
+                onBandLevelChange = playerViewModel::setBandLevel,
+                onPresetSelected = playerViewModel::selectPreset,
+                onBassBoostChange = playerViewModel::setBassBoostStrength,
+                onVirtualizerChange = playerViewModel::setVirtualizerStrength,
+                onReverbSelected = playerViewModel::setReverbPreset,
+                onLyricsDraftChange = playerViewModel::updateLyricsDraft,
+                onLyricsSave = playerViewModel::saveLyrics,
+                onLyricsClear = playerViewModel::clearLyrics,
+                onSampleLyrics = playerViewModel::loadSampleLyrics,
+                onSelectThemeOption = playerViewModel::selectThemeOption,
+                onToggleDarkTheme = playerViewModel::setDarkTheme,
+                onUpdateTagTitle = playerViewModel::updateTagTitle,
+                onUpdateTagArtist = playerViewModel::updateTagArtist,
+                onUpdateTagAlbum = playerViewModel::updateTagAlbum,
+                onSaveTags = playerViewModel::saveTags,
+                onResetTags = playerViewModel::resetTagEditor,
+                onShareCurrentSong = ::shareCurrentSong,
+                onShareSong = ::shareSpecificSong,
+                onTabSelected = playerViewModel::selectTab,
+                onDrawerDestinationSelected = playerViewModel::selectDrawerDestination,
+                onSongSelected = playerViewModel::playSong,
+                onPlayAllSongs = playerViewModel::playAllSongs,
+                onShuffleAllSongs = playerViewModel::shuffleAllSongs,
+                songSort = homeState.songSort,
+                albumSortDirection = homeState.albumSortDirection,
+                artistSortDirection = homeState.artistSortDirection,
+                onSongSortFieldSelected = playerViewModel::setSongSortField,
+                onSongSortDirectionToggle = playerViewModel::toggleSongSortDirection,
+                onAlbumSortToggle = playerViewModel::toggleAlbumSortDirection,
+                onArtistSortToggle = playerViewModel::toggleArtistSortDirection,
+                onToggleQueue = playerViewModel::toggleQueueVisibility,
+                onDismissQueue = playerViewModel::dismissQueue,
+                onRemoveFromQueue = playerViewModel::removeFromQueue,
+                onPlayNext = playerViewModel::playNext,
+                onPlayPrevious = playerViewModel::playPrevious,
+                onSelectLongformFilter = playerViewModel::selectLongformFilter,
+                onOnboardingWelcomeContinue = playerViewModel::continueFromWelcome,
+                onRequestAudioPermission = {
+                    playerViewModel.onPermissionRequestLaunched()
+                    val permission = audioPermission
+                    if (permission == null) {
+                        playerViewModel.handlePermissionResult(granted = true)
+                    } else {
+                        permissionLauncher.launch(permission)
+                    }
+                },
+                onChooseFolders = {
+                    playerViewModel.onPermissionRequestLaunched()
+                    folderLauncher.launch(null)
+                },
+                onAssignAllLongform = playerViewModel::assignAllLongform,
+                onChooseLongformIndividually = playerViewModel::chooseLongformIndividually,
+                onLongformSelectionChange = playerViewModel::updateLongformSelection,
+                onApplyLongformSelection = playerViewModel::applyLongformSelections,
+                onSkipLongform = playerViewModel::skipLongformClassification,
+                onUndoLongformChange = playerViewModel::undoLongformClassification,
+                onConsumeOnboardingMessage = playerViewModel::consumeOnboardingStatusMessage,
+                onCompleteOnboarding = playerViewModel::completeOnboarding
+            )
+        }
+    }
+
+    @Composable
+    private fun rememberLauncherForPermission(onResult: (Boolean) -> Unit) =
+        rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission(), onResult)
+
+    @Composable
+    private fun rememberLauncherForFolder(onResult: (Uri?) -> Unit) =
+        rememberLauncherForActivityResult(ActivityResultContracts.OpenDocumentTree(), onResult)
+
+    private fun shareCurrentSong() {
+        val message = playerViewModel.getCurrentSongShareMessage()
+        if (message != null) {
+            shareSongMessage(message)
+        } else {
+            showShareUnavailable()
+        }
+    }
+
+    private fun shareSpecificSong(songId: String) {
+        val message = playerViewModel.getShareMessageForSong(songId)
+        if (message != null) {
+            shareSongMessage(message)
+        } else {
+            showShareUnavailable()
+        }
+    }
+
+    private fun shareSongMessage(message: SongShareMessage) {
+        val intent = Intent(Intent.ACTION_SEND).apply {
+            type = "text/plain"
+            putExtra(Intent.EXTRA_SUBJECT, message.subject)
+            putExtra(Intent.EXTRA_TEXT, message.text)
+        }
+        val chooser = Intent.createChooser(intent, getString(R.string.share_song_chooser_title))
+        try {
+            startActivity(chooser)
+        } catch (_: ActivityNotFoundException) {
+            showShareUnavailable()
+        }
+    }
+
+    private fun showShareUnavailable() {
+        Toast.makeText(this, getString(R.string.share_song_error), Toast.LENGTH_SHORT).show()
+    }
+
+    private fun determineAudioPermission(): String? {
+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            Manifest.permission.READ_MEDIA_AUDIO
+        } else {
+            Manifest.permission.READ_EXTERNAL_STORAGE
+        }
+    }
+
+    private fun persistFolderAccess(uri: Uri) {
+        val flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
+        try {
+            contentResolver.takePersistableUriPermission(uri, flags)
+        } catch (_: SecurityException) {
+            // Ignore; some providers may not allow persistable grants.
+        }
+    }
+}
diff --git a/app/src/main/java/app/ember/studio/OnboardingScreens.kt b/app/src/main/java/app/ember/studio/OnboardingScreens.kt
new file mode 100644
index 0000000000000000000000000000000000000000..40c2f85654dd8d1c93329a809b832e8912f684ba
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/OnboardingScreens.kt
@@ -0,0 +1,558 @@
+package app.ember.studio
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.rememberScrollState
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.verticalScroll
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.outlined.Check
+import androidx.compose.material.icons.outlined.LibraryMusic
+import androidx.compose.material3.Button
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.FilterChip
+import androidx.compose.material3.Icon
+import androidx.compose.material3.LinearProgressIndicator
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.OutlinedButton
+import androidx.compose.material3.RadioButton
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.SnackbarHost
+import androidx.compose.material3.SnackbarHostState
+import androidx.compose.material3.SnackbarResult
+import androidx.compose.material3.Switch
+import androidx.compose.material3.SwitchDefaults
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.remember
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import app.ember.studio.ui.theme.ThemeUiState
+import app.ember.studio.util.formatDuration
+
+@Composable
+fun OnboardingOverlay(
+    state: OnboardingUiState,
+    themeState: ThemeUiState,
+    onWelcomeContinue: () -> Unit,
+    onRequestPermission: () -> Unit,
+    onChooseFolders: () -> Unit,
+    onAssignAllLongform: (LongformCategory) -> Unit,
+    onChooseIndividually: () -> Unit,
+    onSelectionChange: (String, LongformCategory) -> Unit,
+    onApplySelection: () -> Unit,
+    onSkip: () -> Unit,
+    onUndo: () -> Unit,
+    onDismissMessage: () -> Unit,
+    onComplete: () -> Unit,
+    onSelectThemeOption: (Int) -> Unit,
+    onToggleDarkTheme: (Boolean) -> Unit
+) {
+    val snackbarHostState = remember { SnackbarHostState() }
+    val actionLabel = if (state.canUndoLongformChange) {
+        appString(R.string.onboarding_undo)
+    } else {
+        null
+    }
+
+    val statusMessage = state.statusMessage
+    LaunchedEffect(statusMessage, actionLabel) {
+        if (statusMessage != null) {
+            val result = snackbarHostState.showSnackbar(
+                message = statusMessage,
+                actionLabel = actionLabel
+            )
+            if (result == SnackbarResult.ActionPerformed && state.canUndoLongformChange) {
+                onUndo()
+            }
+            onDismissMessage()
+        }
+    }
+
+    Scaffold(
+        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.98f),
+        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }
+    ) { padding ->
+        Box(
+            modifier = Modifier
+                .fillMaxSize()
+                .padding(padding)
+        ) {
+            when (state.step) {
+                OnboardingStep.Welcome -> WelcomeStep(onContinue = onWelcomeContinue)
+                OnboardingStep.Permission -> PermissionStep(
+                    state = state.permissionState,
+                    onRequestPermission = onRequestPermission,
+                    onChooseFolders = onChooseFolders
+                )
+                OnboardingStep.LongAudio -> LongAudioStep(
+                    state = state.longformState,
+                    onAssignAllLongform = onAssignAllLongform,
+                    onChooseIndividually = onChooseIndividually,
+                    onSelectionChange = onSelectionChange,
+                    onApplySelection = onApplySelection,
+                    onSkip = onSkip
+                )
+                OnboardingStep.Theme -> ThemeStep(
+                    themeState = themeState,
+                    onSelectThemeOption = onSelectThemeOption,
+                    onToggleDarkTheme = onToggleDarkTheme,
+                    onFinish = onComplete
+                )
+                OnboardingStep.Complete -> {}
+            }
+        }
+    }
+}
+
+@Composable
+private fun WelcomeStep(onContinue: () -> Unit) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(horizontal = 32.dp)
+            .verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.Center,
+        horizontalAlignment = Alignment.CenterHorizontally
+    ) {
+        Box(
+            modifier = Modifier
+                .size(96.dp)
+                .clip(CircleShape)
+                .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)),
+            contentAlignment = Alignment.Center
+        ) {
+            Icon(
+                imageVector = Icons.Outlined.LibraryMusic,
+                contentDescription = null,
+                tint = MaterialTheme.colorScheme.primary,
+                modifier = Modifier.size(48.dp)
+            )
+        }
+        Spacer(modifier = Modifier.height(24.dp))
+        Text(
+            text = appString(R.string.onboarding_brand_title),
+            style = MaterialTheme.typography.headlineSmall,
+            fontWeight = FontWeight.Bold
+        )
+        Text(
+            text = appString(R.string.onboarding_brand_subtitle),
+            style = MaterialTheme.typography.bodyLarge,
+            color = MaterialTheme.colorScheme.onSurfaceVariant,
+            modifier = Modifier.padding(top = 8.dp)
+        )
+        Spacer(modifier = Modifier.height(32.dp))
+        Button(onClick = onContinue, modifier = Modifier.fillMaxWidth()) {
+            Text(text = appString(R.string.onboarding_continue))
+        }
+    }
+}
+
+@Composable
+private fun PermissionStep(
+    state: PermissionStepState,
+    onRequestPermission: () -> Unit,
+    onChooseFolders: () -> Unit
+) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(32.dp)
+            .verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.Top,
+        horizontalAlignment = Alignment.Start
+    ) {
+        Text(
+            text = appString(R.string.onboarding_permission_title),
+            style = MaterialTheme.typography.headlineSmall,
+            fontWeight = FontWeight.Bold
+        )
+        Spacer(modifier = Modifier.height(12.dp))
+        Text(
+            text = appString(R.string.onboarding_permission_body),
+            style = MaterialTheme.typography.bodyLarge,
+            color = MaterialTheme.colorScheme.onSurfaceVariant
+        )
+        Spacer(modifier = Modifier.height(32.dp))
+        Button(
+            onClick = onRequestPermission,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_permission_allow))
+        }
+        Spacer(modifier = Modifier.height(12.dp))
+        OutlinedButton(
+            onClick = onChooseFolders,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_permission_choose_folders))
+        }
+        if (state.errorMessage != null) {
+            Spacer(modifier = Modifier.height(16.dp))
+            Text(
+                text = state.errorMessage,
+                color = MaterialTheme.colorScheme.error,
+                style = MaterialTheme.typography.bodyMedium
+            )
+        }
+        if (state.isScanning) {
+            Spacer(modifier = Modifier.height(24.dp))
+            LinearProgressIndicator(modifier = Modifier.fillMaxWidth())
+            val total = state.totalItemCount.coerceAtLeast(1)
+            val scanned = state.scannedItemCount.coerceAtMost(total)
+            Text(
+                text = appString(
+                    R.string.onboarding_scanning_progress,
+                    scanned,
+                    total
+                ),
+                style = MaterialTheme.typography.bodyMedium,
+                modifier = Modifier.padding(top = 8.dp)
+            )
+        }
+    }
+}
+
+@Composable
+private fun LongAudioStep(
+    state: LongformStepState,
+    onAssignAllLongform: (LongformCategory) -> Unit,
+    onChooseIndividually: () -> Unit,
+    onSelectionChange: (String, LongformCategory) -> Unit,
+    onApplySelection: () -> Unit,
+    onSkip: () -> Unit
+) {
+    when (state.mode) {
+        LongformMode.Overview -> LongAudioOverview(
+            state = state,
+            onAssignAllLongform = onAssignAllLongform,
+            onChooseIndividually = onChooseIndividually,
+            onSkip = onSkip
+        )
+        LongformMode.Chooser -> LongAudioChooser(
+            state = state,
+            onSelectionChange = onSelectionChange,
+            onApplySelection = onApplySelection,
+            onSkip = onSkip
+        )
+    }
+}
+
+@Composable
+private fun LongAudioOverview(
+    state: LongformStepState,
+    onAssignAllLongform: (LongformCategory) -> Unit,
+    onChooseIndividually: () -> Unit,
+    onSkip: () -> Unit
+) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(32.dp)
+            .verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.Top
+    ) {
+        Text(
+            text = appString(R.string.onboarding_long_audio_title),
+            style = MaterialTheme.typography.headlineSmall,
+            fontWeight = FontWeight.Bold
+        )
+        Spacer(modifier = Modifier.height(8.dp))
+        Text(
+            text = appString(R.string.onboarding_long_audio_subtitle),
+            style = MaterialTheme.typography.bodyLarge,
+            color = MaterialTheme.colorScheme.onSurfaceVariant
+        )
+        Spacer(modifier = Modifier.height(16.dp))
+        Box(
+            modifier = Modifier
+                .clip(CircleShape)
+                .background(MaterialTheme.colorScheme.secondary.copy(alpha = 0.15f))
+                .padding(horizontal = 16.dp, vertical = 8.dp)
+        ) {
+            Text(
+                text = appString(R.string.onboarding_long_audio_count, state.itemCount),
+                style = MaterialTheme.typography.labelLarge
+            )
+        }
+        Spacer(modifier = Modifier.height(24.dp))
+        Button(
+            onClick = { onAssignAllLongform(LongformCategory.Audiobook) },
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_long_audio_import_audiobooks))
+        }
+        Spacer(modifier = Modifier.height(12.dp))
+        Button(
+            onClick = { onAssignAllLongform(LongformCategory.Podcast) },
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_long_audio_import_podcasts))
+        }
+        Spacer(modifier = Modifier.height(12.dp))
+        OutlinedButton(
+            onClick = onChooseIndividually,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_long_audio_choose_individually))
+        }
+        Spacer(modifier = Modifier.height(12.dp))
+        OutlinedButton(
+            onClick = onSkip,
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(text = appString(R.string.onboarding_long_audio_skip))
+        }
+        Spacer(modifier = Modifier.height(16.dp))
+        Text(
+            text = appString(R.string.onboarding_long_audio_hint),
+            style = MaterialTheme.typography.bodySmall,
+            color = MaterialTheme.colorScheme.onSurfaceVariant
+        )
+    }
+}
+
+@Composable
+private fun LongAudioChooser(
+    state: LongformStepState,
+    onSelectionChange: (String, LongformCategory) -> Unit,
+    onApplySelection: () -> Unit,
+    onSkip: () -> Unit
+) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(horizontal = 16.dp)
+    ) {
+        Text(
+            text = appString(R.string.onboarding_long_audio_sort_header, state.itemCount),
+            style = MaterialTheme.typography.titleLarge,
+            fontWeight = FontWeight.Bold,
+            modifier = Modifier.padding(top = 24.dp, bottom = 8.dp)
+        )
+        Text(
+            text = appString(R.string.onboarding_long_audio_hint),
+            style = MaterialTheme.typography.bodySmall,
+            color = MaterialTheme.colorScheme.onSurfaceVariant,
+            modifier = Modifier.padding(bottom = 16.dp)
+        )
+        LazyColumn(
+            modifier = Modifier.weight(1f),
+            contentPadding = PaddingValues(bottom = 24.dp)
+        ) {
+            items(state.candidates) { candidate ->
+                LongformCandidateRow(candidate = candidate, onSelectionChange = onSelectionChange)
+                Spacer(modifier = Modifier.height(12.dp))
+            }
+        }
+        Button(onClick = onApplySelection, modifier = Modifier.fillMaxWidth()) {
+            Text(text = appString(R.string.onboarding_long_audio_apply))
+        }
+        OutlinedButton(
+            onClick = onSkip,
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(top = 12.dp, bottom = 24.dp)
+        ) {
+            Text(text = appString(R.string.onboarding_long_audio_skip))
+        }
+    }
+}
+
+@Composable
+private fun LongformCandidateRow(
+    candidate: LongformCandidate,
+    onSelectionChange: (String, LongformCategory) -> Unit
+) {
+    Card(
+        modifier = Modifier.fillMaxWidth(),
+        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
+    ) {
+        Column(modifier = Modifier.padding(16.dp)) {
+            Text(
+                text = candidate.title,
+                style = MaterialTheme.typography.titleMedium,
+                maxLines = 1,
+                overflow = TextOverflow.Ellipsis
+            )
+            Text(
+                text = candidate.source,
+                style = MaterialTheme.typography.bodySmall,
+                color = MaterialTheme.colorScheme.onSurfaceVariant,
+                maxLines = 1,
+                overflow = TextOverflow.Ellipsis,
+                modifier = Modifier.padding(top = 4.dp)
+            )
+            Text(
+                text = formatDuration(candidate.durationMs),
+                style = MaterialTheme.typography.bodySmall,
+                modifier = Modifier.padding(top = 4.dp)
+            )
+            Spacer(modifier = Modifier.height(12.dp))
+            Row(
+                horizontalArrangement = Arrangement.spacedBy(8.dp)
+            ) {
+                CategoryChip(
+                    label = appString(R.string.onboarding_long_audio_music),
+                    selected = candidate.selectedCategory == LongformCategory.Unassigned,
+                    onClick = { onSelectionChange(candidate.id, LongformCategory.Unassigned) }
+                )
+                CategoryChip(
+                    label = appString(R.string.onboarding_long_audio_podcast),
+                    selected = candidate.selectedCategory == LongformCategory.Podcast,
+                    onClick = { onSelectionChange(candidate.id, LongformCategory.Podcast) }
+                )
+                CategoryChip(
+                    label = appString(R.string.onboarding_long_audio_audiobook),
+                    selected = candidate.selectedCategory == LongformCategory.Audiobook,
+                    onClick = { onSelectionChange(candidate.id, LongformCategory.Audiobook) }
+                )
+            }
+            if (candidate.suggestedCategory != candidate.selectedCategory) {
+                Text(
+                    text = appString(
+                        R.string.onboarding_long_audio_suggested,
+                        suggestionLabel(candidate.suggestedCategory)
+                    ),
+                    style = MaterialTheme.typography.bodySmall,
+                    color = MaterialTheme.colorScheme.onSurfaceVariant,
+                    modifier = Modifier.padding(top = 8.dp)
+                )
+            }
+        }
+    }
+}
+
+@Composable
+private fun CategoryChip(label: String, selected: Boolean, onClick: () -> Unit) {
+    FilterChip(
+        selected = selected,
+        onClick = onClick,
+        label = { Text(text = label) },
+        leadingIcon = if (selected) {
+            {
+                Icon(
+                    imageVector = Icons.Outlined.Check,
+                    contentDescription = null,
+                    modifier = Modifier.size(18.dp)
+                )
+            }
+        } else {
+            null
+        }
+    )
+}
+
+@Composable
+private fun ThemeStep(
+    themeState: ThemeUiState,
+    onSelectThemeOption: (Int) -> Unit,
+    onToggleDarkTheme: (Boolean) -> Unit,
+    onFinish: () -> Unit
+) {
+    Column(
+        modifier = Modifier
+            .fillMaxSize()
+            .padding(24.dp)
+            .verticalScroll(rememberScrollState()),
+        verticalArrangement = Arrangement.Top
+    ) {
+        Text(
+            text = appString(R.string.onboarding_theme_title),
+            style = MaterialTheme.typography.headlineSmall,
+            fontWeight = FontWeight.Bold
+        )
+        Spacer(modifier = Modifier.height(8.dp))
+        Text(
+            text = appString(R.string.onboarding_theme_hint),
+            style = MaterialTheme.typography.bodyLarge,
+            color = MaterialTheme.colorScheme.onSurfaceVariant
+        )
+        Spacer(modifier = Modifier.height(24.dp))
+        themeState.options.forEachIndexed { index, option ->
+            ThemeOptionCard(
+                label = appString(option.labelRes),
+                selected = index == themeState.selectedOptionIndex,
+                onSelect = { onSelectThemeOption(index) }
+            )
+            Spacer(modifier = Modifier.height(12.dp))
+        }
+        Row(
+            verticalAlignment = Alignment.CenterVertically,
+            modifier = Modifier.padding(vertical = 16.dp)
+        ) {
+            Text(
+                text = appString(R.string.onboarding_theme_dark_toggle),
+                style = MaterialTheme.typography.bodyLarge,
+                modifier = Modifier.weight(1f)
+            )
+            Switch(
+                checked = themeState.useDarkTheme,
+                onCheckedChange = onToggleDarkTheme,
+                colors = SwitchDefaults.colors(checkedThumbColor = MaterialTheme.colorScheme.primary)
+            )
+        }
+        Button(onClick = onFinish, modifier = Modifier.fillMaxWidth()) {
+            Text(text = appString(R.string.onboarding_finish))
+        }
+    }
+}
+
+@Composable
+private fun ThemeOptionCard(label: String, selected: Boolean, onSelect: () -> Unit) {
+    Card(
+        modifier = Modifier.fillMaxWidth(),
+        colors = CardDefaults.cardColors(
+            containerColor = if (selected) {
+                MaterialTheme.colorScheme.primary.copy(alpha = 0.16f)
+            } else {
+                MaterialTheme.colorScheme.surfaceVariant
+            }
+        ),
+        onClick = onSelect
+    ) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(16.dp),
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Text(
+                text = label,
+                style = MaterialTheme.typography.titleMedium,
+                modifier = Modifier.weight(1f)
+            )
+            RadioButton(selected = selected, onClick = onSelect)
+        }
+    }
+}
+
+@Composable
+private fun appString(resId: Int, vararg formatArgs: Any): String {
+    return androidx.compose.ui.res.stringResource(id = resId, formatArgs = formatArgs)
+}
+
+@Composable
+private fun suggestionLabel(category: LongformCategory): String = when (category) {
+    LongformCategory.Podcast -> appString(R.string.onboarding_long_audio_podcast)
+    LongformCategory.Audiobook -> appString(R.string.onboarding_long_audio_audiobook)
+    LongformCategory.Unassigned -> appString(R.string.onboarding_long_audio_music)
+}
diff --git a/app/src/main/java/app/ember/studio/PlayerViewModel.kt b/app/src/main/java/app/ember/studio/PlayerViewModel.kt
new file mode 100644
index 0000000000000000000000000000000000000000..d887fd373a31048d9013c92fec52067568058d33
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/PlayerViewModel.kt
@@ -0,0 +1,1240 @@
+package app.ember.studio
+
+import android.app.Application
+import android.media.audiofx.BassBoost
+import android.media.audiofx.Equalizer
+import android.media.audiofx.PresetReverb
+import android.media.audiofx.Virtualizer
+import android.net.Uri
+import androidx.annotation.StringRes
+import androidx.lifecycle.AndroidViewModel
+import androidx.lifecycle.viewModelScope
+import androidx.media3.common.C
+import androidx.media3.common.MediaItem
+import androidx.media3.common.MediaMetadata
+import androidx.media3.common.Player
+import androidx.media3.exoplayer.ExoPlayer
+import app.ember.studio.ui.theme.ThemeUiState
+import app.ember.studio.util.formatDuration
+import app.ember.studio.util.formatFrequencyLabel
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.flow.update
+import kotlinx.coroutines.launch
+import kotlin.collections.LinkedHashSet
+
+class PlayerViewModel(application: Application) : AndroidViewModel(application) {
+    private val appContext = application
+    private val player: ExoPlayer = ExoPlayer.Builder(application).build()
+    private val listener = object : Player.Listener {
+        override fun onEvents(player: Player, events: Player.Events) {
+            if (events.contains(Player.EVENT_AUDIO_SESSION_ID)) {
+                ensureAudioEffects()
+            }
+            if (
+                events.contains(Player.EVENT_MEDIA_METADATA_CHANGED) ||
+                events.contains(Player.EVENT_PLAY_WHEN_READY_CHANGED) ||
+                events.contains(Player.EVENT_IS_PLAYING_CHANGED) ||
+                events.contains(Player.EVENT_POSITION_DISCONTINUITY) ||
+                events.contains(Player.EVENT_PLAYBACK_STATE_CHANGED)
+            ) {
+                updateState()
+            }
+        }
+    }
+
+    private var equalizer: Equalizer? = null
+    private var bassBoost: BassBoost? = null
+    private var virtualizer: Virtualizer? = null
+    private var presetReverb: PresetReverb? = null
+    private var currentAudioSessionId: Int = C.AUDIO_SESSION_ID_UNSET
+
+    private val allSongs = SampleLibrary.songs
+    private val allAlbums = SampleLibrary.albums
+    private val allArtists = SampleLibrary.artists
+    private var longformLibrary: List<LongformItem> = SampleLibrary.longformItems
+    private var currentSongIndex: Int = allSongs.indices.firstOrNull() ?: 0
+    private var currentSongId: String? = allSongs.firstOrNull()?.id
+
+    private val _homeState = MutableStateFlow(
+        HomeUiState(
+            selectedTab = HomeTab.Songs,
+            songs = sortSongs(allSongs, SongSortState()),
+            playlists = SampleLibrary.playlists,
+            folders = SampleLibrary.folders,
+            albums = sortAlbums(allAlbums, SortDirection.Ascending),
+            artists = sortArtists(allArtists, SortDirection.Ascending),
+            genres = SampleLibrary.genres,
+            longformItems = longformLibrary,
+            longformFilter = LongformFilter.All,
+            videos = SampleLibrary.videos,
+            drawerDestinations = defaultDrawerDestinations(),
+            songSort = SongSortState(),
+            albumSortDirection = SortDirection.Ascending,
+            artistSortDirection = SortDirection.Ascending
+        )
+    )
+    val homeState: StateFlow<HomeUiState> = _homeState.asStateFlow()
+
+    private var queueOrder: MutableList<String> = _homeState.value.songs.map { it.id }.toMutableList()
+
+    private val _uiState = MutableStateFlow(PlayerUiState())
+    val uiState: StateFlow<PlayerUiState> = _uiState.asStateFlow()
+
+    private val _equalizerState = MutableStateFlow(
+        EqualizerUiState(reverbOptions = buildReverbOptions())
+    )
+    val equalizerState: StateFlow<EqualizerUiState> = _equalizerState.asStateFlow()
+
+    private val _lyricsState = MutableStateFlow(LyricsUiState())
+    val lyricsState: StateFlow<LyricsUiState> = _lyricsState.asStateFlow()
+
+    private val _themeState = MutableStateFlow(ThemeUiState())
+    val themeState: StateFlow<ThemeUiState> = _themeState.asStateFlow()
+
+    private val _tagEditorState = MutableStateFlow(TagEditorUiState())
+    val tagEditorState: StateFlow<TagEditorUiState> = _tagEditorState.asStateFlow()
+
+    private val _onboardingState = MutableStateFlow(createInitialOnboardingState())
+    val onboardingState: StateFlow<OnboardingUiState> = _onboardingState.asStateFlow()
+
+    private var hasCompletedInitialScan = false
+    private var previousLongformLibrary: List<LongformItem>? = null
+
+    private var userTitleOverride: String? = null
+    private var userArtistOverride: String? = null
+    private var userAlbumOverride: String? = null
+
+    init {
+        player.addListener(listener)
+        player.repeatMode = Player.REPEAT_MODE_ALL
+        val firstSong = allSongs.firstOrNull()
+        if (firstSong != null) {
+            prepareSong(firstSong, autoPlay = false)
+        }
+        ensureAudioEffects()
+        updateState()
+        syncTagEditorFromPlayer()
+        recomputeQueueState()
+        observePositionChanges()
+    }
+
+    override fun onCleared() {
+        player.removeListener(listener)
+        player.release()
+        releaseAudioEffects()
+        super.onCleared()
+    }
+
+    fun selectTab(tab: HomeTab) {
+        _homeState.update { it.copy(selectedTab = tab) }
+    }
+
+    fun selectDrawerDestination(destinationId: DrawerDestinationId) {
+        _homeState.update { it.copy(selectedDrawerDestination = destinationId) }
+    }
+
+    fun toggleQueueVisibility() {
+        _homeState.update { it.copy(isQueueVisible = !it.isQueueVisible) }
+    }
+
+    fun dismissQueue() {
+        _homeState.update { it.copy(isQueueVisible = false) }
+    }
+
+    fun selectLongformFilter(filter: LongformFilter) {
+        _homeState.update { it.copy(longformFilter = filter) }
+    }
+
+    fun setSongSortField(field: SongSortField) {
+        val current = homeState.value.songSort
+        if (current.field == field) return
+        val updated = current.copy(field = field, direction = field.defaultDirection)
+        applySongSort(updated)
+    }
+
+    fun toggleSongSortDirection() {
+        val current = homeState.value.songSort
+        val updated = current.copy(direction = current.direction.toggled())
+        applySongSort(updated)
+    }
+
+    fun toggleAlbumSortDirection() {
+        val next = homeState.value.albumSortDirection.toggled()
+        applyAlbumSort(next)
+    }
+
+    fun toggleArtistSortDirection() {
+        val next = homeState.value.artistSortDirection.toggled()
+        applyArtistSort(next)
+    }
+
+    fun playSong(songId: String) {
+        val songs = homeState.value.songs
+        val song = songs.firstOrNull { it.id == songId } ?: return
+        ensureSongInQueue(songId, songs)
+        val index = queueOrder.indexOf(songId).takeIf { it >= 0 } ?: return
+        currentSongIndex = index
+        prepareSong(song, autoPlay = true)
+        recomputeQueueState(index)
+    }
+
+    fun playAllSongs() {
+        val songs = homeState.value.songs
+        if (songs.isEmpty()) return
+        queueOrder = songs.map { it.id }.toMutableList()
+        currentSongIndex = 0
+        val firstSong = songs.first()
+        prepareSong(firstSong, autoPlay = true)
+        recomputeQueueState(0)
+    }
+
+    fun shuffleAllSongs() {
+        val songs = homeState.value.songs
+        if (songs.isEmpty()) return
+        val shuffled = songs.shuffled()
+        queueOrder = shuffled.map { it.id }.toMutableList()
+        currentSongIndex = 0
+        val song = shuffled.first()
+        prepareSong(song, autoPlay = true)
+        recomputeQueueState(0)
+    }
+
+    fun playNext() {
+        if (queueOrder.isEmpty()) return
+        currentSongIndex = (currentSongIndex + 1).mod(queueOrder.size)
+        val nextId = queueOrder.getOrNull(currentSongIndex) ?: return
+        val song = findSongById(nextId) ?: return
+        prepareSong(song, autoPlay = true)
+        recomputeQueueState(currentSongIndex)
+    }
+
+    fun playPrevious() {
+        if (queueOrder.isEmpty()) return
+        currentSongIndex = if (currentSongIndex - 1 < 0) queueOrder.lastIndex else currentSongIndex - 1
+        val previousId = queueOrder.getOrNull(currentSongIndex) ?: return
+        val song = findSongById(previousId) ?: return
+        prepareSong(song, autoPlay = true)
+        recomputeQueueState(currentSongIndex)
+    }
+
+    fun removeFromQueue(songId: String) {
+        if (!queueOrder.contains(songId)) return
+        val removingIndex = queueOrder.indexOf(songId)
+        if (queueOrder.size == 1) {
+            queueOrder.clear()
+            currentSongIndex = 0
+            currentSongId = null
+            player.stop()
+            _homeState.update { it.copy(queue = QueueUiState()) }
+            return
+        }
+
+        val removingCurrent = songId == currentSongId
+        queueOrder.removeAt(removingIndex)
+
+        if (removingCurrent) {
+            val shouldPlay = player.playWhenReady
+            currentSongIndex = removingIndex.coerceAtMost(queueOrder.lastIndex)
+            val nextId = queueOrder.getOrNull(currentSongIndex)
+            val nextSong = nextId?.let { findSongById(it) }
+            if (nextSong != null) {
+                prepareSong(nextSong, autoPlay = shouldPlay)
+            } else {
+                currentSongId = null
+                player.stop()
+            }
+        } else if (removingIndex < currentSongIndex) {
+            currentSongIndex -= 1
+        }
+
+        recomputeQueueState(currentSongIndex)
+    }
+
+    fun togglePlayPause() {
+        player.playWhenReady = !player.playWhenReady
+    }
+
+    fun seekTo(positionMs: Long) {
+        val duration = player.duration.takeIf { it > 0 } ?: 0L
+        player.seekTo(positionMs.coerceIn(0L, duration))
+    }
+
+    fun setEqualizerEnabled(enabled: Boolean) {
+        ensureAudioEffects()
+        val eq = equalizer ?: return
+        eq.enabled = enabled
+        _equalizerState.update { it.copy(isEnabled = enabled, isAvailable = true) }
+    }
+
+    fun setBandLevel(bandIndex: Int, levelMillibels: Int) {
+        ensureAudioEffects()
+        val eq = equalizer ?: return
+        val range = eq.bandLevelRange
+        val clamped = levelMillibels.coerceIn(range[0].toInt(), range[1].toInt())
+        eq.setBandLevel(bandIndex.toShort(), clamped.toShort())
+        refreshEqualizerState(selectedPresetOverride = -1) { state ->
+            state.copy(
+                bands = state.bands.updateBandLevel(bandIndex, clamped),
+                selectedPresetIndex = -1
+            )
+        }
+    }
+
+    fun selectPreset(index: Int) {
+        ensureAudioEffects()
+        val eq = equalizer ?: return
+        if (index !in 0 until eq.numberOfPresets) return
+        try {
+            eq.usePreset(index.toShort())
+            eq.enabled = true
+            refreshEqualizerState(selectedPresetOverride = index)
+        } catch (_: IllegalArgumentException) {
+            // Ignore invalid preset errors.
+        }
+    }
+
+    fun setBassBoostStrength(strength: Int) {
+        ensureAudioEffects()
+        val boost = bassBoost ?: return
+        val clamped = strength.coerceIn(0, MAX_EFFECT_STRENGTH)
+        boost.enabled = clamped > 0
+        if (boost.strengthSupported) {
+            boost.setStrength(clamped.toShort())
+        }
+        _equalizerState.update {
+            it.copy(
+                isBassBoostSupported = boost.strengthSupported,
+                bassBoostStrength = clamped
+            )
+        }
+    }
+
+    fun setVirtualizerStrength(strength: Int) {
+        ensureAudioEffects()
+        val effect = virtualizer ?: return
+        val clamped = strength.coerceIn(0, MAX_EFFECT_STRENGTH)
+        effect.enabled = clamped > 0
+        if (effect.strengthSupported) {
+            effect.setStrength(clamped.toShort())
+        }
+        _equalizerState.update {
+            it.copy(
+                isVirtualizerSupported = effect.strengthSupported,
+                virtualizerStrength = clamped
+            )
+        }
+    }
+
+    fun setReverbPreset(preset: Short) {
+        ensureAudioEffects()
+        val reverb = presetReverb ?: return
+        reverb.preset = preset
+        reverb.enabled = preset != PresetReverb.PRESET_NONE
+        _equalizerState.update { it.copy(selectedReverbPreset = preset) }
+    }
+
+    fun updateLyricsDraft(text: String) {
+        _lyricsState.update { it.copy(draftLyrics = text, statusMessage = null) }
+    }
+
+    fun saveLyrics() {
+        _lyricsState.update {
+            it.copy(
+                currentLyrics = it.draftLyrics,
+                statusMessage = appContext.getString(R.string.lyrics_saved_message)
+            )
+        }
+    }
+
+    fun clearLyrics() {
+        _lyricsState.update {
+            it.copy(
+                currentLyrics = "",
+                draftLyrics = "",
+                statusMessage = appContext.getString(R.string.lyrics_cleared_message)
+            )
+        }
+    }
+
+    fun loadSampleLyrics() {
+        val sample = appContext.getString(R.string.sample_lyrics_body)
+        _lyricsState.update {
+            it.copy(
+                draftLyrics = sample,
+                statusMessage = appContext.getString(R.string.lyrics_sample_loaded_message)
+            )
+        }
+    }
+
+    fun selectThemeOption(index: Int) {
+        _themeState.update { state ->
+            val options = state.options
+            if (options.isEmpty()) state else state.copy(selectedOptionIndex = index.coerceIn(0, options.lastIndex))
+        }
+    }
+
+    fun setDarkTheme(useDarkTheme: Boolean) {
+        _themeState.update { it.copy(useDarkTheme = useDarkTheme) }
+    }
+
+    fun updateTagTitle(value: String) {
+        _tagEditorState.update { state ->
+            val trimmed = value
+            state.copy(
+                titleInput = trimmed,
+                isDirty = isTagDirty(trimmed, state.artistInput, state.albumInput),
+                statusMessage = null
+            )
+        }
+    }
+
+    fun updateTagArtist(value: String) {
+        _tagEditorState.update { state ->
+            val trimmed = value
+            state.copy(
+                artistInput = trimmed,
+                isDirty = isTagDirty(state.titleInput, trimmed, state.albumInput),
+                statusMessage = null
+            )
+        }
+    }
+
+    fun updateTagAlbum(value: String) {
+        _tagEditorState.update { state ->
+            val trimmed = value
+            state.copy(
+                albumInput = trimmed,
+                isDirty = isTagDirty(state.titleInput, state.artistInput, trimmed),
+                statusMessage = null
+            )
+        }
+    }
+
+    fun saveTags() {
+        val currentEditor = _tagEditorState.value
+        val title = currentEditor.titleInput.ifBlank { appContext.getString(R.string.sample_tone_title) }
+        val artist = currentEditor.artistInput.ifBlank { appContext.getString(R.string.sample_tone_artist) }
+        val album = currentEditor.albumInput.ifBlank { appContext.getString(R.string.sample_album_title) }
+        userTitleOverride = title
+        userArtistOverride = artist
+        userAlbumOverride = album
+        _uiState.update {
+            it.copy(
+                title = title,
+                artist = artist,
+                album = album
+            )
+        }
+        _tagEditorState.update {
+            it.copy(
+                titleInput = title,
+                artistInput = artist,
+                albumInput = album,
+                isDirty = false,
+                statusMessage = appContext.getString(R.string.tag_editor_saved_message)
+            )
+        }
+    }
+
+    fun resetTagEditor() {
+        val current = _uiState.value
+        _tagEditorState.update {
+            it.copy(
+                titleInput = current.title,
+                artistInput = current.artist,
+                albumInput = current.album,
+                isDirty = false,
+                statusMessage = null
+            )
+        }
+    }
+
+    fun getShareMessageForSong(songId: String): SongShareMessage? {
+        val song = allSongs.find { it.id == songId } ?: return null
+        return buildShareMessage(
+            title = song.title,
+            artist = song.artist.ifBlank { appContext.getString(R.string.sample_tone_artist) }
+        )
+    }
+
+    fun getCurrentSongShareMessage(): SongShareMessage? {
+        val currentId = _uiState.value.currentSongId ?: return null
+        val stateTitle = _uiState.value.title
+        val stateArtist = _uiState.value.artist
+        val fallback = allSongs.find { it.id == currentId }
+        val title = stateTitle.ifBlank { fallback?.title ?: return null }
+        val artist = stateArtist.ifBlank { fallback?.artist ?: appContext.getString(R.string.sample_tone_artist) }
+        return buildShareMessage(title = title, artist = artist)
+    }
+
+    private fun buildShareMessage(title: String, artist: String): SongShareMessage {
+        val subject = appContext.getString(R.string.share_song_subject, title)
+        val text = appContext.getString(R.string.share_song_text, title, artist)
+        return SongShareMessage(subject = subject, text = text)
+    }
+
+    fun continueFromWelcome() {
+        _onboardingState.update { state ->
+            if (!state.isVisible || state.step != OnboardingStep.Welcome) {
+                state
+            } else {
+                state.copy(step = OnboardingStep.Permission)
+            }
+        }
+    }
+
+    fun onPermissionRequestLaunched() {
+        _onboardingState.update { state ->
+            state.copy(
+                permissionState = state.permissionState.copy(errorMessage = null)
+            )
+        }
+    }
+
+    fun onInitialPermissionGranted() {
+        triggerInitialScan()
+    }
+
+    fun handlePermissionResult(granted: Boolean) {
+        if (granted) {
+            triggerInitialScan()
+        } else {
+            _onboardingState.update { state ->
+                state.copy(
+                    permissionState = state.permissionState.copy(
+                        errorMessage = appContext.getString(R.string.onboarding_permission_error),
+                        isPermissionGranted = false
+                    )
+                )
+            }
+        }
+    }
+
+    fun onFolderSelected(uri: Uri) {
+        _onboardingState.update { state ->
+            state.copy(
+                permissionState = state.permissionState.copy(
+                    isPermissionGranted = true,
+                    selectedFolderCount = state.permissionState.selectedFolderCount + 1,
+                    errorMessage = null
+                )
+            )
+        }
+        triggerInitialScan()
+    }
+
+    fun onFolderSelectionCancelled() {
+        if (!_onboardingState.value.permissionState.isPermissionGranted) {
+            _onboardingState.update { state ->
+                state.copy(
+                    permissionState = state.permissionState.copy(
+                        errorMessage = appContext.getString(R.string.onboarding_permission_error)
+                    )
+                )
+            }
+        }
+    }
+
+    fun assignAllLongform(category: LongformCategory) {
+        val candidates = _onboardingState.value.longformState.candidates
+        if (candidates.isEmpty()) {
+            proceedToThemeStep()
+            return
+        }
+        val selection = candidates.associate { it.id to category }
+        val messageRes = when (category) {
+            LongformCategory.Podcast -> R.string.onboarding_long_audio_sorted_podcasts
+            LongformCategory.Audiobook -> R.string.onboarding_long_audio_sorted_audiobooks
+            LongformCategory.Unassigned -> R.string.onboarding_long_audio_sorted_music
+        }
+        applyLongformSelection(selection, messageRes)
+    }
+
+    fun chooseLongformIndividually() {
+        _onboardingState.update { state ->
+            if (state.longformState.candidates.isEmpty()) {
+                state
+            } else {
+                state.copy(longformState = state.longformState.copy(mode = LongformMode.Chooser))
+            }
+        }
+    }
+
+    fun updateLongformSelection(itemId: String, category: LongformCategory) {
+        _onboardingState.update { state ->
+            val updatedCandidates = state.longformState.candidates.map { candidate ->
+                if (candidate.id == itemId) {
+                    candidate.copy(selectedCategory = category)
+                } else {
+                    candidate
+                }
+            }
+            state.copy(longformState = state.longformState.copy(candidates = updatedCandidates))
+        }
+    }
+
+    fun applyLongformSelections() {
+        val state = _onboardingState.value
+        val selection = state.longformState.candidates.associate { it.id to it.selectedCategory }
+        applyLongformSelection(selection, R.string.onboarding_long_audio_applied)
+    }
+
+    fun skipLongformClassification() {
+        proceedToThemeStep()
+    }
+
+    fun undoLongformClassification() {
+        val snapshot = previousLongformLibrary ?: return
+        longformLibrary = snapshot
+        previousLongformLibrary = null
+        _homeState.update { state ->
+            state.copy(longformItems = longformLibrary)
+        }
+        _onboardingState.update { state ->
+            state.copy(
+                statusMessage = appContext.getString(R.string.onboarding_long_audio_undo_message),
+                canUndoLongformChange = false
+            )
+        }
+    }
+
+    fun consumeOnboardingStatusMessage() {
+        if (_onboardingState.value.statusMessage != null) {
+            _onboardingState.update { state -> state.copy(statusMessage = null) }
+        }
+    }
+
+    fun completeOnboarding() {
+        _onboardingState.update { state ->
+            state.copy(isVisible = false, step = OnboardingStep.Complete, statusMessage = null)
+        }
+    }
+
+    private fun prepareSong(song: SongSummary, autoPlay: Boolean) {
+        val mediaItem = song.toMediaItem(appContext)
+        player.setMediaItem(mediaItem)
+        player.prepare()
+        player.playWhenReady = autoPlay
+        currentSongId = song.id
+        userTitleOverride = song.title
+        userArtistOverride = song.artist
+        userAlbumOverride = song.album
+        updateState()
+        syncTagEditorFromPlayer()
+    }
+
+    private fun triggerInitialScan() {
+        if (hasCompletedInitialScan) {
+            advanceBeyondPermission()
+            return
+        }
+        hasCompletedInitialScan = true
+        viewModelScope.launch {
+            _onboardingState.update { state ->
+                state.copy(
+                    permissionState = state.permissionState.copy(
+                        isPermissionGranted = true,
+                        errorMessage = null,
+                        isScanning = true,
+                        totalItemCount = allSongs.size,
+                        scannedItemCount = 0
+                    )
+                )
+            }
+            allSongs.forEachIndexed { index, _ ->
+                delay(SCAN_PROGRESS_DELAY_MS)
+                _onboardingState.update { state ->
+                    state.copy(
+                        permissionState = state.permissionState.copy(
+                            scannedItemCount = index + 1
+                        )
+                    )
+                }
+            }
+            _homeState.update {
+                it.copy(
+                    playlists = SampleLibrary.playlists,
+                    folders = SampleLibrary.folders,
+                    genres = SampleLibrary.genres,
+                    longformItems = longformLibrary,
+                    videos = SampleLibrary.videos
+                )
+            }
+            applySongSort(homeState.value.songSort)
+            applyAlbumSort(homeState.value.albumSortDirection)
+            applyArtistSort(homeState.value.artistSortDirection)
+            _onboardingState.update { state ->
+                state.copy(
+                    permissionState = state.permissionState.copy(
+                        isScanning = false,
+                        scannedItemCount = allSongs.size
+                    )
+                )
+            }
+            advanceBeyondPermission()
+        }
+    }
+
+    private fun advanceBeyondPermission() {
+        val candidates = computeLongformCandidates(longformLibrary)
+        _onboardingState.update { state ->
+            val updatedLongform = state.longformState.copy(
+                candidates = candidates,
+                mode = LongformMode.Overview
+            )
+            val nextStep = if (candidates.isEmpty()) OnboardingStep.Theme else OnboardingStep.LongAudio
+            state.copy(
+                permissionState = state.permissionState.copy(
+                    isPermissionGranted = true,
+                    isScanning = false,
+                    errorMessage = null,
+                    totalItemCount = allSongs.size,
+                    scannedItemCount = allSongs.size
+                ),
+                longformState = updatedLongform,
+                step = nextStep
+            )
+        }
+    }
+
+    private fun applyLongformSelection(
+        selection: Map<String, LongformCategory>,
+        @StringRes messageRes: Int
+    ) {
+        if (selection.isEmpty()) {
+            proceedToThemeStep()
+            return
+        }
+        previousLongformLibrary = longformLibrary
+        val updatedLibrary = longformLibrary.map { item ->
+            val newCategory = selection[item.id] ?: item.category
+            if (newCategory == item.category) {
+                item
+            } else {
+                item.copy(category = newCategory)
+            }
+        }
+        longformLibrary = updatedLibrary
+        _homeState.update { state ->
+            state.copy(longformItems = updatedLibrary)
+        }
+        _onboardingState.update { state ->
+            state.copy(
+                longformState = state.longformState.copy(
+                    candidates = state.longformState.candidates.map { candidate ->
+                        val updatedCategory = selection[candidate.id] ?: candidate.selectedCategory
+                        candidate.copy(selectedCategory = updatedCategory)
+                    },
+                    mode = LongformMode.Overview
+                ),
+                statusMessage = appContext.getString(messageRes),
+                canUndoLongformChange = true,
+                step = OnboardingStep.Theme
+            )
+        }
+    }
+
+    private fun proceedToThemeStep() {
+        previousLongformLibrary = null
+        _onboardingState.update { state ->
+            state.copy(
+                longformState = state.longformState.copy(mode = LongformMode.Overview),
+                statusMessage = null,
+                canUndoLongformChange = false,
+                step = OnboardingStep.Theme
+            )
+        }
+    }
+
+    private fun applySongSort(sortState: SongSortState) {
+        val sortedSongs = sortSongs(allSongs, sortState)
+        rebuildQueueFromSongs(sortedSongs)
+        _homeState.update {
+            it.copy(
+                songs = sortedSongs,
+                songSort = sortState
+            )
+        }
+        recomputeQueueState(currentSongIndex)
+    }
+
+    private fun applyAlbumSort(direction: SortDirection) {
+        val sorted = sortAlbums(allAlbums, direction)
+        _homeState.update {
+            it.copy(
+                albums = sorted,
+                albumSortDirection = direction
+            )
+        }
+    }
+
+    private fun applyArtistSort(direction: SortDirection) {
+        val sorted = sortArtists(allArtists, direction)
+        _homeState.update {
+            it.copy(
+                artists = sorted,
+                artistSortDirection = direction
+            )
+        }
+    }
+
+    private fun recomputeQueueState(indexOverride: Int? = null) {
+        _homeState.update { state ->
+            if (queueOrder.isEmpty()) {
+                currentSongId = null
+                currentSongIndex = 0
+                state.copy(queue = QueueUiState())
+            } else {
+                val songsById = state.songs.associateBy { it.id }
+                val index = indexOverride ?: currentSongIndex.coerceIn(0, queueOrder.lastIndex)
+                currentSongIndex = index
+                val nowPlayingId = queueOrder.getOrNull(index)
+                val nowPlaying = nowPlayingId?.let { songsById[it] }
+                currentSongId = nowPlaying?.id
+                val history = queueOrder.take(index).mapNotNull { songsById[it] }
+                val upNext = queueOrder.drop(index + 1).mapNotNull { songsById[it] }
+                if (nowPlaying == null) {
+                    state.copy(queue = QueueUiState())
+                } else {
+                    state.copy(
+                        queue = QueueUiState(
+                            history = history,
+                            nowPlaying = nowPlaying,
+                            upNext = upNext
+                        )
+                    )
+                }
+            }
+        }
+    }
+
+    private fun rebuildQueueFromSongs(songs: List<SongSummary>) {
+        val validIds = songs.map { it.id }
+        val validIdSet = validIds.toSet()
+        val orderedIds = LinkedHashSet<String>()
+        queueOrder.forEach { id ->
+            if (id in validIdSet) {
+                orderedIds += id
+            }
+        }
+        validIds.forEach { id -> orderedIds += id }
+        val newOrder = orderedIds.toMutableList()
+        if (newOrder.isEmpty()) {
+            newOrder.addAll(validIds)
+        }
+        queueOrder = newOrder
+        val currentId = currentSongId
+        currentSongIndex = when {
+            currentId != null && queueOrder.contains(currentId) -> queueOrder.indexOf(currentId)
+            queueOrder.isNotEmpty() -> currentSongIndex.coerceIn(0, queueOrder.lastIndex)
+            else -> 0
+        }
+        if (queueOrder.isNotEmpty()) {
+            currentSongId = queueOrder[currentSongIndex]
+        } else {
+            currentSongId = null
+        }
+    }
+
+    private fun ensureSongInQueue(songId: String, songs: List<SongSummary>) {
+        if (queueOrder.contains(songId)) return
+        val precedingIds = songs.takeWhile { it.id != songId }.map { it.id }
+        val insertAfter = precedingIds.asReversed().firstOrNull { queueOrder.contains(it) }
+        val insertionIndex = if (insertAfter != null) {
+            queueOrder.indexOf(insertAfter) + 1
+        } else {
+            0
+        }
+        queueOrder.add(insertionIndex, songId)
+    }
+
+    private fun findSongById(songId: String): SongSummary? {
+        return homeState.value.songs.firstOrNull { it.id == songId }
+    }
+
+    private fun observePositionChanges() {
+        viewModelScope.launch(Dispatchers.Main) {
+            while (true) {
+                updateState()
+                delay(if (player.playWhenReady && player.isPlaying) POSITION_UPDATE_INTERVAL_PLAYING_MS else POSITION_UPDATE_INTERVAL_PAUSED_MS)
+            }
+        }
+    }
+
+    private fun updateState() {
+        _uiState.update { current ->
+            val metadata = player.mediaMetadata
+            val title = userTitleOverride ?: metadata.title?.toString()
+                ?: appContext.getString(R.string.sample_tone_title)
+            val artist = userArtistOverride ?: metadata.artist?.toString()
+                ?: appContext.getString(R.string.sample_tone_artist)
+            val album = userAlbumOverride ?: metadata.albumTitle?.toString()
+                ?: appContext.getString(R.string.sample_album_title)
+            current.copy(
+                currentSongId = currentSongId,
+                title = title,
+                artist = artist,
+                album = album,
+                isPlaying = player.playWhenReady && player.playbackState == Player.STATE_READY,
+                durationMs = player.duration.takeIf { it > 0 } ?: 0L,
+                positionMs = player.currentPosition.coerceIn(0L, player.duration.takeIf { it > 0 } ?: 0L)
+            )
+        }
+        syncTagEditorFromPlayer()
+    }
+
+    private fun ensureAudioEffects() {
+        val sessionId = player.audioSessionId
+        if (sessionId == C.AUDIO_SESSION_ID_UNSET) {
+            return
+        }
+        if (sessionId == currentAudioSessionId && equalizer != null) {
+            refreshEqualizerState()
+            return
+        }
+        releaseAudioEffects()
+        currentAudioSessionId = sessionId
+        try {
+            equalizer = Equalizer(0, sessionId).apply { enabled = true }
+            bassBoost = BassBoost(0, sessionId).apply { enabled = false }
+            virtualizer = Virtualizer(0, sessionId).apply { enabled = false }
+            presetReverb = PresetReverb(0, sessionId).apply { enabled = false }
+            refreshEqualizerState()
+        } catch (_: RuntimeException) {
+            releaseAudioEffects()
+            _equalizerState.value = EqualizerUiState(
+                isAvailable = false,
+                reverbOptions = buildReverbOptions()
+            )
+        } catch (_: IllegalArgumentException) {
+            releaseAudioEffects()
+            _equalizerState.value = EqualizerUiState(
+                isAvailable = false,
+                reverbOptions = buildReverbOptions()
+            )
+        }
+    }
+
+    private fun refreshEqualizerState(
+        selectedPresetOverride: Int? = null,
+        transform: ((EqualizerUiState) -> EqualizerUiState)? = null
+    ) {
+        val eq = equalizer ?: run {
+            _equalizerState.value = EqualizerUiState(
+                isAvailable = false,
+                reverbOptions = buildReverbOptions()
+            )
+            return
+        }
+        val presets = (0 until eq.numberOfPresets).map { index ->
+            eq.getPresetName(index.toShort())
+        }
+        val selectedPresetIndex = selectedPresetOverride
+            ?: _equalizerState.value.selectedPresetIndex.takeIf { it in presets.indices } ?: -1
+        val bandRange = eq.bandLevelRange
+        val bands = (0 until eq.numberOfBands).map { index ->
+            val centerFrequency = eq.getCenterFreq(index.toShort()).toInt()
+            EqualizerBandState(
+                index = index,
+                label = formatFrequencyLabel(centerFrequency),
+                levelMillibels = eq.getBandLevel(index.toShort()).toInt(),
+                minLevelMillibels = bandRange[0].toInt(),
+                maxLevelMillibels = bandRange[1].toInt()
+            )
+        }
+        val bass = bassBoost
+        val virt = virtualizer
+        val reverb = presetReverb
+        var newState = EqualizerUiState(
+            isAvailable = true,
+            isEnabled = eq.enabled,
+            bands = bands,
+            presets = presets,
+            selectedPresetIndex = selectedPresetIndex,
+            isBassBoostSupported = bass?.strengthSupported == true,
+            bassBoostStrength = bass?.roundedStrength?.toInt() ?: 0,
+            isVirtualizerSupported = virt?.strengthSupported == true,
+            virtualizerStrength = virt?.roundedStrength?.toInt() ?: 0,
+            reverbOptions = buildReverbOptions(),
+            selectedReverbPreset = reverb?.preset ?: PresetReverb.PRESET_NONE
+        )
+        if (transform != null) {
+            newState = transform(newState)
+        }
+        _equalizerState.value = newState
+    }
+
+    private fun releaseAudioEffects() {
+        equalizer?.release()
+        bassBoost?.release()
+        virtualizer?.release()
+        presetReverb?.release()
+        equalizer = null
+        bassBoost = null
+        virtualizer = null
+        presetReverb = null
+        currentAudioSessionId = C.AUDIO_SESSION_ID_UNSET
+        _equalizerState.value = EqualizerUiState(
+            isAvailable = false,
+            reverbOptions = buildReverbOptions()
+        )
+    }
+
+    private fun syncTagEditorFromPlayer() {
+        val current = _uiState.value
+        _tagEditorState.update { state ->
+            if (state.isDirty) {
+                state
+            } else {
+                state.copy(
+                    titleInput = current.title,
+                    artistInput = current.artist,
+                    albumInput = current.album
+                )
+            }
+        }
+    }
+
+    private fun isTagDirty(title: String, artist: String, album: String): Boolean {
+        val current = _uiState.value
+        return current.title != title || current.artist != artist || current.album != album
+    }
+
+    private fun buildReverbOptions(): List<ReverbOption> = listOf(
+        ReverbOption(PresetReverb.PRESET_NONE, appContext.getString(R.string.reverb_none)),
+        ReverbOption(PresetReverb.PRESET_SMALLROOM, appContext.getString(R.string.reverb_small_room)),
+        ReverbOption(PresetReverb.PRESET_MEDIUMROOM, appContext.getString(R.string.reverb_medium_room)),
+        ReverbOption(PresetReverb.PRESET_LARGEROOM, appContext.getString(R.string.reverb_large_room)),
+        ReverbOption(PresetReverb.PRESET_MEDIUMHALL, appContext.getString(R.string.reverb_medium_hall)),
+        ReverbOption(PresetReverb.PRESET_LARGEHALL, appContext.getString(R.string.reverb_large_hall)),
+        ReverbOption(PresetReverb.PRESET_PLATE, appContext.getString(R.string.reverb_plate))
+    )
+
+    private fun SongSummary.toMediaItem(application: Application): MediaItem {
+        val metadata = MediaMetadata.Builder()
+            .setTitle(title)
+            .setArtist(artist)
+            .setAlbumTitle(album)
+            .build()
+        val builder = MediaItem.Builder()
+            .setMediaId(id)
+            .setMediaMetadata(metadata)
+        val uri = rawResId?.let { resId ->
+            Uri.parse("rawresource://${application.packageName}/$resId")
+        }
+        if (uri != null) {
+            builder.setUri(uri)
+        }
+        return builder.build()
+    }
+
+    private fun createInitialOnboardingState(): OnboardingUiState {
+        val candidates = computeLongformCandidates(longformLibrary)
+        return OnboardingUiState(
+            isVisible = true,
+            step = OnboardingStep.Welcome,
+            permissionState = PermissionStepState(totalItemCount = allSongs.size),
+            longformState = LongformStepState(candidates = candidates)
+        )
+    }
+
+    private fun computeLongformCandidates(items: List<LongformItem>): List<LongformCandidate> {
+        return items.filter { it.durationMs >= LONGFORM_THRESHOLD_MS }
+            .map { item ->
+                val suggested = suggestLongformCategory(
+                    title = item.title,
+                    source = item.source,
+                    existingCategory = item.category,
+                    durationMs = item.durationMs
+                )
+                val initial = when {
+                    item.category != LongformCategory.Unassigned -> item.category
+                    suggested != LongformCategory.Unassigned -> suggested
+                    else -> LongformCategory.Unassigned
+                }
+                LongformCandidate(
+                    id = item.id,
+                    title = item.title,
+                    durationMs = item.durationMs,
+                    source = item.source,
+                    suggestedCategory = suggested,
+                    selectedCategory = initial
+                )
+            }
+    }
+
+    companion object {
+        private const val POSITION_UPDATE_INTERVAL_PLAYING_MS = 500L
+        private const val POSITION_UPDATE_INTERVAL_PAUSED_MS = 1000L
+        private const val MAX_EFFECT_STRENGTH = 1000
+        private const val SCAN_PROGRESS_DELAY_MS = 120L
+    }
+}
+
+enum class HomeTab(@StringRes val titleRes: Int) {
+    Songs(R.string.songs_tab),
+    Playlists(R.string.playlists_tab),
+    Folders(R.string.folders_tab),
+    Albums(R.string.albums_tab),
+    Artists(R.string.artists_tab),
+    Genres(R.string.genres_tab),
+    Longform(R.string.longform_tab),
+    Videos(R.string.videos_tab)
+}
+
+data class HomeUiState(
+    val selectedTab: HomeTab = HomeTab.Songs,
+    val songs: List<SongSummary> = emptyList(),
+    val playlists: List<PlaylistSummary> = emptyList(),
+    val folders: List<FolderSummary> = emptyList(),
+    val albums: List<AlbumSummary> = emptyList(),
+    val artists: List<ArtistSummary> = emptyList(),
+    val genres: List<GenreSummary> = emptyList(),
+    val longformItems: List<LongformItem> = emptyList(),
+    val longformFilter: LongformFilter = LongformFilter.All,
+    val videos: List<VideoSummary> = emptyList(),
+    val drawerDestinations: List<DrawerDestination> = emptyList(),
+    val selectedDrawerDestination: DrawerDestinationId = DrawerDestinationId.Library,
+    val songSort: SongSortState = SongSortState(),
+    val albumSortDirection: SortDirection = SortDirection.Ascending,
+    val artistSortDirection: SortDirection = SortDirection.Ascending,
+    val queue: QueueUiState = QueueUiState(),
+    val isQueueVisible: Boolean = false
+) {
+    val filteredLongformItems: List<LongformItem>
+        get() = when (longformFilter) {
+            LongformFilter.All -> longformItems
+            LongformFilter.Podcasts -> longformItems.filter { it.category == LongformCategory.Podcast }
+            LongformFilter.Audiobooks -> longformItems.filter { it.category == LongformCategory.Audiobook }
+            LongformFilter.Unassigned -> longformItems.filter { it.category == LongformCategory.Unassigned }
+        }
+}
+
+data class QueueUiState(
+    val history: List<SongSummary> = emptyList(),
+    val nowPlaying: SongSummary? = null,
+    val upNext: List<SongSummary> = emptyList()
+)
+
+data class PlayerUiState(
+    val currentSongId: String? = null,
+    val title: String = "",
+    val artist: String = "",
+    val album: String = "",
+    val isPlaying: Boolean = false,
+    val positionMs: Long = 0L,
+    val durationMs: Long = 0L
+) {
+    val positionText: String get() = formatDuration(positionMs)
+    val durationText: String get() = formatDuration(durationMs)
+}
+
+data class EqualizerUiState(
+    val isAvailable: Boolean = false,
+    val isEnabled: Boolean = false,
+    val bands: List<EqualizerBandState> = emptyList(),
+    val presets: List<String> = emptyList(),
+    val selectedPresetIndex: Int = -1,
+    val isBassBoostSupported: Boolean = false,
+    val bassBoostStrength: Int = 0,
+    val isVirtualizerSupported: Boolean = false,
+    val virtualizerStrength: Int = 0,
+    val reverbOptions: List<ReverbOption> = emptyList(),
+    val selectedReverbPreset: Short = PresetReverb.PRESET_NONE
+)
+
+data class EqualizerBandState(
+    val index: Int,
+    val label: String,
+    val levelMillibels: Int,
+    val minLevelMillibels: Int,
+    val maxLevelMillibels: Int
+)
+
+data class ReverbOption(
+    val preset: Short,
+    val label: String
+)
+
+data class LyricsUiState(
+    val currentLyrics: String = "",
+    val draftLyrics: String = "",
+    val statusMessage: String? = null
+) {
+    val isSaveEnabled: Boolean get() = draftLyrics.isNotBlank()
+}
+
+data class TagEditorUiState(
+    val titleInput: String = "",
+    val artistInput: String = "",
+    val albumInput: String = "",
+    val isDirty: Boolean = false,
+    val statusMessage: String? = null
+)
+
+data class SongShareMessage(
+    val subject: String,
+    val text: String
+)
+
+enum class OnboardingStep {
+    Welcome,
+    Permission,
+    LongAudio,
+    Theme,
+    Complete
+}
+
+data class OnboardingUiState(
+    val isVisible: Boolean = true,
+    val step: OnboardingStep = OnboardingStep.Welcome,
+    val permissionState: PermissionStepState = PermissionStepState(),
+    val longformState: LongformStepState = LongformStepState(),
+    val statusMessage: String? = null,
+    val canUndoLongformChange: Boolean = false
+)
+
+data class PermissionStepState(
+    val isPermissionGranted: Boolean = false,
+    val selectedFolderCount: Int = 0,
+    val isScanning: Boolean = false,
+    val scannedItemCount: Int = 0,
+    val totalItemCount: Int = 0,
+    val errorMessage: String? = null
+)
+
+data class LongformStepState(
+    val candidates: List<LongformCandidate> = emptyList(),
+    val mode: LongformMode = LongformMode.Overview
+) {
+    val itemCount: Int get() = candidates.size
+    val hasCandidates: Boolean get() = candidates.isNotEmpty()
+}
+
+enum class LongformMode {
+    Overview,
+    Chooser
+}
+
+data class LongformCandidate(
+    val id: String,
+    val title: String,
+    val durationMs: Long,
+    val source: String,
+    val suggestedCategory: LongformCategory,
+    val selectedCategory: LongformCategory
+)
+
+private fun List<EqualizerBandState>.updateBandLevel(index: Int, levelMillibels: Int): List<EqualizerBandState> =
+    map { band ->
+        if (band.index == index) {
+            band.copy(levelMillibels = levelMillibels)
+        } else {
+            band
+        }
+    }
+*** End of File
diff --git a/app/src/main/java/app/ember/studio/SampleLibrary.kt b/app/src/main/java/app/ember/studio/SampleLibrary.kt
new file mode 100644
index 0000000000000000000000000000000000000000..0ec62586ab5c8fee0c8ad7c4c9d57c41610b15aa
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/SampleLibrary.kt
@@ -0,0 +1,292 @@
+package app.ember.studio
+
+import androidx.annotation.StringRes
+import app.ember.studio.R
+
+/**
+ * Static sample content used to demonstrate the library shell before real scanning is wired up.
+ */
+object SampleLibrary {
+    val songs: List<SongSummary> = listOf(
+        SongSummary(
+            id = "track_molten_dawn",
+            title = "Molten Dawn",
+            artist = "Ember Ensemble",
+            album = "Glow Theory",
+            durationMs = 215_000,
+            rawResId = R.raw.sample_tone,
+            addedTimestampMs = 1_721_260_800_000
+        ),
+        SongSummary(
+            id = "track_cinder_groove",
+            title = "Cinder Groove",
+            artist = "Ashline",
+            album = "Glow Theory",
+            durationMs = 198_000,
+            rawResId = R.raw.sample_tone,
+            addedTimestampMs = 1_721_347_200_000
+        ),
+        SongSummary(
+            id = "track_spark_echoes",
+            title = "Spark Echoes",
+            artist = "Radiant Fields",
+            album = "Kindling",
+            durationMs = 242_000,
+            rawResId = R.raw.sample_tone,
+            addedTimestampMs = 1_721_433_600_000
+        ),
+        SongSummary(
+            id = "track_glass_forge",
+            title = "Glass Forge",
+            artist = "Helix Forge",
+            album = "Molten Lines",
+            durationMs = 264_000,
+            rawResId = R.raw.sample_tone,
+            addedTimestampMs = 1_721_520_000_000
+        ),
+        SongSummary(
+            id = "track_ember_skyline",
+            title = "Ember Skyline",
+            artist = "City Sparks",
+            album = "Night Copper",
+            durationMs = 230_000,
+            rawResId = R.raw.sample_tone,
+            addedTimestampMs = 1_721_606_400_000
+        )
+    )
+
+    val playlists: List<PlaylistSummary> = listOf(
+        PlaylistSummary(
+            id = "playlist_favourites",
+            title = "My favourite",
+            trackCount = 24,
+            totalDurationMs = 5_400_000
+        ),
+        PlaylistSummary(
+            id = "playlist_recently_added",
+            title = "Recently added",
+            trackCount = 12,
+            totalDurationMs = 2_600_000
+        ),
+        PlaylistSummary(
+            id = "playlist_workout",
+            title = "Workout Fire",
+            trackCount = 18,
+            totalDurationMs = 4_020_000
+        )
+    )
+
+    val folders: List<FolderSummary> = listOf(
+        FolderSummary(
+            id = "folder_downloads",
+            name = "Downloads",
+            path = "Storage/Downloads/Audio",
+            trackCount = 32
+        ),
+        FolderSummary(
+            id = "folder_field",
+            name = "Field Recordings",
+            path = "Storage/Music/Field",
+            trackCount = 9
+        )
+    )
+
+    val albums: List<AlbumSummary> = listOf(
+        AlbumSummary(
+            id = "album_glow_theory",
+            title = "Glow Theory",
+            artist = "Ember Ensemble",
+            trackCount = 12
+        ),
+        AlbumSummary(
+            id = "album_kindling",
+            title = "Kindling",
+            artist = "Radiant Fields",
+            trackCount = 10
+        ),
+        AlbumSummary(
+            id = "album_molten_lines",
+            title = "Molten Lines",
+            artist = "Helix Forge",
+            trackCount = 11
+        )
+    )
+
+    val artists: List<ArtistSummary> = listOf(
+        ArtistSummary(
+            id = "artist_ember_ensemble",
+            name = "Ember Ensemble",
+            albumCount = 2,
+            trackCount = 24
+        ),
+        ArtistSummary(
+            id = "artist_radiant_fields",
+            name = "Radiant Fields",
+            albumCount = 1,
+            trackCount = 10
+        ),
+        ArtistSummary(
+            id = "artist_city_sparks",
+            name = "City Sparks",
+            albumCount = 1,
+            trackCount = 8
+        )
+    )
+
+    val genres: List<GenreSummary> = listOf(
+        GenreSummary(
+            id = "genre_electronic",
+            name = "Electronic",
+            trackCount = 34
+        ),
+        GenreSummary(
+            id = "genre_ambient",
+            name = "Ambient",
+            trackCount = 12
+        ),
+        GenreSummary(
+            id = "genre_chillwave",
+            name = "Chillwave",
+            trackCount = 9
+        )
+    )
+
+    val longformItems: List<LongformItem> = listOf(
+        LongformItem(
+            id = "longform_forge_stories",
+            title = "Forge Stories",
+            category = LongformCategory.Podcast,
+            durationMs = 2_700_000,
+            source = "Helix Radio"
+        ),
+        LongformItem(
+            id = "longform_molten_chapter",
+            title = "Molten Chapter 1",
+            category = LongformCategory.Audiobook,
+            durationMs = 4_500_000,
+            source = "Molten Saga"
+        ),
+        LongformItem(
+            id = "longform_soundscape",
+            title = "Soundscape Session",
+            category = LongformCategory.Unassigned,
+            durationMs = 3_000_000,
+            source = "Ember Archive"
+        )
+    )
+
+    val videos: List<VideoSummary> = listOf(
+        VideoSummary(
+            id = "video_live_session",
+            title = "Live Session — Ember Ensemble",
+            durationMs = 360_000
+        ),
+        VideoSummary(
+            id = "video_city_sparks",
+            title = "City Sparks Visualizer",
+            durationMs = 220_000
+        )
+    )
+}
+
+/** Library drawer destinations displayed in the navigation drawer. */
+fun defaultDrawerDestinations(): List<DrawerDestination> = listOf(
+    DrawerDestination(DrawerDestinationId.Library, R.string.drawer_library),
+    DrawerDestination(DrawerDestinationId.Equalizer, R.string.drawer_equalizer),
+    DrawerDestination(DrawerDestinationId.SleepTimer, R.string.drawer_sleep_timer),
+    DrawerDestination(DrawerDestinationId.ThemeStudio, R.string.drawer_theme_studio),
+    DrawerDestination(DrawerDestinationId.Widgets, R.string.drawer_widgets),
+    DrawerDestination(DrawerDestinationId.ScanImport, R.string.drawer_scan_import),
+    DrawerDestination(DrawerDestinationId.Settings, R.string.drawer_settings),
+    DrawerDestination(DrawerDestinationId.Help, R.string.drawer_help)
+)
+
+/**
+ * Summary objects used by the library shell. These will be replaced by real data when scanning lands.
+ */
+data class SongSummary(
+    val id: String,
+    val title: String,
+    val artist: String,
+    val album: String,
+    val durationMs: Long,
+    val rawResId: Int?,
+    val addedTimestampMs: Long = 0L
+)
+
+data class PlaylistSummary(
+    val id: String,
+    val title: String,
+    val trackCount: Int,
+    val totalDurationMs: Long
+)
+
+data class FolderSummary(
+    val id: String,
+    val name: String,
+    val path: String,
+    val trackCount: Int
+)
+
+data class AlbumSummary(
+    val id: String,
+    val title: String,
+    val artist: String,
+    val trackCount: Int
+)
+
+data class ArtistSummary(
+    val id: String,
+    val name: String,
+    val albumCount: Int,
+    val trackCount: Int
+)
+
+data class GenreSummary(
+    val id: String,
+    val name: String,
+    val trackCount: Int
+)
+
+data class LongformItem(
+    val id: String,
+    val title: String,
+    val category: LongformCategory,
+    val durationMs: Long,
+    val source: String
+)
+
+enum class LongformCategory {
+    Podcast,
+    Audiobook,
+    Unassigned
+}
+
+enum class LongformFilter(@StringRes val labelRes: Int) {
+    All(R.string.longform_filter_all),
+    Podcasts(R.string.longform_filter_podcasts),
+    Audiobooks(R.string.longform_filter_audiobooks),
+    Unassigned(R.string.longform_filter_unassigned)
+}
+
+data class VideoSummary(
+    val id: String,
+    val title: String,
+    val durationMs: Long
+)
+
+data class DrawerDestination(
+    val id: DrawerDestinationId,
+    @StringRes val titleRes: Int
+)
+
+enum class DrawerDestinationId {
+    Library,
+    Equalizer,
+    SleepTimer,
+    ThemeStudio,
+    Widgets,
+    ScanImport,
+    Settings,
+    Help
+}
diff --git a/app/src/main/java/app/ember/studio/SearchModels.kt b/app/src/main/java/app/ember/studio/SearchModels.kt
new file mode 100644
index 0000000000000000000000000000000000000000..07b41ed540f19595da98564316e69a8471e22e73
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/SearchModels.kt
@@ -0,0 +1,84 @@
+package app.ember.studio
+
+import androidx.annotation.StringRes
+
+enum class SearchBucket(@StringRes val labelRes: Int) {
+    All(R.string.search_bucket_all),
+    Songs(R.string.search_bucket_songs),
+    Playlists(R.string.search_bucket_playlists),
+    Folders(R.string.search_bucket_folders),
+    Albums(R.string.search_bucket_albums),
+    Artists(R.string.search_bucket_artists),
+    Genres(R.string.search_bucket_genres),
+    Longform(R.string.search_bucket_longform),
+    Videos(R.string.search_bucket_videos)
+}
+
+data class SearchResults(
+    val songs: List<SongSummary> = emptyList(),
+    val playlists: List<PlaylistSummary> = emptyList(),
+    val folders: List<FolderSummary> = emptyList(),
+    val albums: List<AlbumSummary> = emptyList(),
+    val artists: List<ArtistSummary> = emptyList(),
+    val genres: List<GenreSummary> = emptyList(),
+    val longform: List<LongformItem> = emptyList(),
+    val videos: List<VideoSummary> = emptyList()
+) {
+    val totalCount: Int
+        get() = songs.size + playlists.size + folders.size + albums.size + artists.size + genres.size + longform.size + videos.size
+
+    val isEmpty: Boolean get() = totalCount == 0
+}
+
+data class SearchUiState(
+    val query: String = "",
+    val bucket: SearchBucket = SearchBucket.All,
+    val results: SearchResults = SearchResults(),
+    val isEmpty: Boolean = false
+)
+
+data class SearchCorpus(
+    val songs: List<SongSummary>,
+    val playlists: List<PlaylistSummary>,
+    val folders: List<FolderSummary>,
+    val albums: List<AlbumSummary>,
+    val artists: List<ArtistSummary>,
+    val genres: List<GenreSummary>,
+    val longform: List<LongformItem>,
+    val videos: List<VideoSummary>
+)
+
+fun searchLibrary(corpus: SearchCorpus, query: String): SearchResults {
+    if (query.isBlank()) return SearchResults()
+    val term = query.trim()
+
+    fun matches(value: String?): Boolean = value?.contains(term, ignoreCase = true) == true
+
+    val songs = corpus.songs.filter { song ->
+        matches(song.title) || matches(song.artist) || matches(song.album)
+    }
+    val playlists = corpus.playlists.filter { matches(it.title) }
+    val folders = corpus.folders.filter { folder ->
+        matches(folder.name) || matches(folder.path)
+    }
+    val albums = corpus.albums.filter { album ->
+        matches(album.title) || matches(album.artist)
+    }
+    val artists = corpus.artists.filter { matches(it.name) }
+    val genres = corpus.genres.filter { matches(it.name) }
+    val longform = corpus.longform.filter { item ->
+        matches(item.title) || matches(item.source) || matches(item.category.name)
+    }
+    val videos = corpus.videos.filter { matches(it.title) }
+
+    return SearchResults(
+        songs = songs,
+        playlists = playlists,
+        folders = folders,
+        albums = albums,
+        artists = artists,
+        genres = genres,
+        longform = longform,
+        videos = videos
+    )
+}
diff --git a/app/src/main/java/app/ember/studio/ui/theme/Theme.kt b/app/src/main/java/app/ember/studio/ui/theme/Theme.kt
new file mode 100644
index 0000000000000000000000000000000000000000..504217209500b62fa5a6f4c689254758c37a6f2b
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/ui/theme/Theme.kt
@@ -0,0 +1,21 @@
+package app.ember.studio.ui.theme
+
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.runtime.Composable
+
+@Composable
+fun EmberAudioPlayerTheme(
+    themeState: ThemeUiState,
+    content: @Composable () -> Unit
+) {
+    val palette = themeState.selectedOption
+    val colorScheme = if (themeState.useDarkTheme) {
+        palette.darkColorScheme
+    } else {
+        palette.lightColorScheme
+    }
+    MaterialTheme(
+        colorScheme = colorScheme,
+        content = content
+    )
+}
diff --git a/app/src/main/java/app/ember/studio/ui/theme/ThemeState.kt b/app/src/main/java/app/ember/studio/ui/theme/ThemeState.kt
new file mode 100644
index 0000000000000000000000000000000000000000..ed654526d936a75cb55ec89a317f5c6078eadd8d
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/ui/theme/ThemeState.kt
@@ -0,0 +1,130 @@
+package app.ember.studio.ui.theme
+
+import androidx.annotation.StringRes
+import androidx.compose.material3.Brightness
+import androidx.compose.material3.ColorScheme
+import androidx.compose.material3.ColorScheme.Companion.fromSeed
+import androidx.compose.ui.graphics.Color
+import androidx.core.graphics.ColorUtils
+import app.ember.studio.R
+
+/**
+ * Represents the active theme selection and the available palette options.
+ */
+data class ThemeUiState(
+    val options: List<ThemeOption> = defaultThemeOptions(),
+    val selectedOptionIndex: Int = 0,
+    val useDarkTheme: Boolean = true
+) {
+    val selectedOption: ThemeOption
+        get() = options.getOrElse(selectedOptionIndex) { options.first() }
+}
+
+/**
+ * Describes a single palette option that can render both light and dark color schemes.
+ */
+data class ThemeOption(
+    val id: String,
+    @StringRes val labelRes: Int,
+    private val palette: ThemePalette
+) {
+    val lightColorScheme: ColorScheme by lazy { palette.colorScheme(Brightness.Light) }
+    val darkColorScheme: ColorScheme by lazy { palette.colorScheme(Brightness.Dark) }
+}
+
+private data class ThemePalette(
+    val accentHue: Float,
+    val accentSaturation: Float,
+    val accentLightness: Float,
+    val secondaryHueOffset: Float,
+    val tertiaryHueOffset: Float,
+    val neutralSaturation: Float,
+    val neutralLightness: Float
+) {
+    fun colorScheme(brightness: Brightness): ColorScheme {
+        val accent = colorFromHsl(accentHue, accentSaturation, accentLightness.adjustForBrightness(brightness))
+        val secondary = colorFromHsl(
+            accentHue.offset(secondaryHueOffset),
+            (accentSaturation * 0.75f).coerceIn(0f, 1f),
+            (accentLightness + 0.1f).coerceIn(0f, 1f).adjustForBrightness(brightness)
+        )
+        val tertiary = colorFromHsl(
+            accentHue.offset(tertiaryHueOffset),
+            (accentSaturation * 0.6f).coerceIn(0f, 1f),
+            (accentLightness - 0.05f).coerceIn(0f, 1f).adjustForBrightness(brightness)
+        )
+        val neutral = colorFromHsl(
+            accentHue.offset(180f),
+            neutralSaturation,
+            neutralLightness.adjustForBrightness(brightness)
+        )
+
+        return ColorScheme.fromSeed(
+            seedColor = accent,
+            secondary = secondary,
+            tertiary = tertiary,
+            background = neutral,
+            surface = neutral,
+            brightness = brightness
+        )
+    }
+}
+
+private fun Float.adjustForBrightness(brightness: Brightness): Float =
+    when (brightness) {
+        Brightness.Light -> (this + 0.05f).coerceAtMost(0.98f)
+        Brightness.Dark -> (this - 0.08f).coerceAtLeast(0.12f)
+    }
+
+private fun Float.offset(delta: Float): Float {
+    val raw = this + delta
+    return if (raw < 0f) raw + 360f else if (raw >= 360f) raw - 360f else raw
+}
+
+private fun colorFromHsl(hue: Float, saturation: Float, lightness: Float): Color {
+    val hsl = floatArrayOf(hue, saturation.coerceIn(0f, 1f), lightness.coerceIn(0f, 1f))
+    val argb = ColorUtils.HSLToColor(hsl)
+    return Color(argb)
+}
+
+fun defaultThemeOptions(): List<ThemeOption> = listOf(
+    ThemeOption(
+        id = "ember_classic",
+        labelRes = R.string.theme_option_ember,
+        palette = ThemePalette(
+            accentHue = 24f,
+            accentSaturation = 0.88f,
+            accentLightness = 0.58f,
+            secondaryHueOffset = 8f,
+            tertiaryHueOffset = -6f,
+            neutralSaturation = 0.12f,
+            neutralLightness = 0.22f
+        )
+    ),
+    ThemeOption(
+        id = "night_copper",
+        labelRes = R.string.theme_option_night,
+        palette = ThemePalette(
+            accentHue = 32f,
+            accentSaturation = 0.78f,
+            accentLightness = 0.54f,
+            secondaryHueOffset = 160f,
+            tertiaryHueOffset = -18f,
+            neutralSaturation = 0.18f,
+            neutralLightness = 0.16f
+        )
+    ),
+    ThemeOption(
+        id = "mono_graphite",
+        labelRes = R.string.theme_option_graphite,
+        palette = ThemePalette(
+            accentHue = 0f,
+            accentSaturation = 0.02f,
+            accentLightness = 0.54f,
+            secondaryHueOffset = 12f,
+            tertiaryHueOffset = -18f,
+            neutralSaturation = 0.04f,
+            neutralLightness = 0.2f
+        )
+    )
+)
diff --git a/app/src/main/java/app/ember/studio/util/AudioFormat.kt b/app/src/main/java/app/ember/studio/util/AudioFormat.kt
new file mode 100644
index 0000000000000000000000000000000000000000..58f7ed22a180100f5f57efcecad60fbfd189ed10
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/util/AudioFormat.kt
@@ -0,0 +1,20 @@
+package app.ember.studio.util
+
+import java.util.Locale
+
+/**
+ * Formats the center frequency reported by the audio equalizer into a concise label.
+ */
+fun formatFrequencyLabel(centerFrequencyMilliHertz: Int): String {
+    val hertz = centerFrequencyMilliHertz / 1000
+    return if (hertz >= 1000) {
+        val kilohertz = hertz / 1000f
+        if (kilohertz >= 10f) {
+            String.format(Locale.US, "%.0f kHz", kilohertz)
+        } else {
+            String.format(Locale.US, "%.1f kHz", kilohertz)
+        }
+    } else {
+        String.format(Locale.US, "%d Hz", hertz)
+    }
+}
diff --git a/app/src/main/java/app/ember/studio/util/TimeFormat.kt b/app/src/main/java/app/ember/studio/util/TimeFormat.kt
new file mode 100644
index 0000000000000000000000000000000000000000..b5963b089069c2a8b92953eb90a67c70737f8182
--- /dev/null
+++ b/app/src/main/java/app/ember/studio/util/TimeFormat.kt
@@ -0,0 +1,14 @@
+package app.ember.studio.util
+
+fun formatDuration(valueMs: Long): String {
+    if (valueMs <= 0L) return "0:00"
+    val totalSeconds = valueMs / 1000
+    val hours = totalSeconds / 3600
+    val minutes = (totalSeconds % 3600) / 60
+    val seconds = totalSeconds % 60
+    return if (hours > 0) {
+        "%d:%02d:%02d".format(hours, minutes, seconds)
+    } else {
+        "%d:%02d".format(minutes, seconds)
+    }
+}
diff --git a/app/src/main/res/drawable/ic_launcher_foreground.xml b/app/src/main/res/drawable/ic_launcher_foreground.xml
new file mode 100644
index 0000000000000000000000000000000000000000..1ce66bc92b8a5e8158b90c7f8cc80422de4f2bdf
--- /dev/null
+++ b/app/src/main/res/drawable/ic_launcher_foreground.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <group
+        android:translateX="27"
+        android:translateY="27">
+        <path
+            android:fillColor="#FFBB86FC"
+            android:pathData="M27,0C12.088,0 0,12.088 0,27s12.088,27 27,27 27,-12.088 27,-27S41.912,0 27,0z" />
+        <path
+            android:fillColor="#FFFFFFFF"
+            android:pathData="M24,18l18,9 -18,9z" />
+    </group>
+</vector>
diff --git a/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml b/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
new file mode 100644
index 0000000000000000000000000000000000000000..80a5340e4c2c93c5edaa4e2189d20cb5108fe581
--- /dev/null
+++ b/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@android:color/white" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
diff --git a/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml b/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
new file mode 100644
index 0000000000000000000000000000000000000000..80a5340e4c2c93c5edaa4e2189d20cb5108fe581
--- /dev/null
+++ b/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@android:color/white" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+</adaptive-icon>
diff --git a/app/src/main/res/raw/sample_tone.wav b/app/src/main/res/raw/sample_tone.wav
new file mode 100644
index 0000000000000000000000000000000000000000..0038db1f168a3e313dd3b206c640a5d7d7de7c11
GIT binary patch
literal 176444
zcmeI*_dAu38wYUNX(>txDU}9g6b&Dekwn8N#3?J3?0v@boZ}q(SlP2AN)#zcA*De^
zp@D{#5EU8-ef=BX>v~`3*Yn$R?(<yN>$>mv+vK3W{*Dq}o)g-~_0F94krn0P;h8u0
z(JkcR3A32T!^<Pe<6!G!D?0Zb9v*(-d7|GW9<A}0=ihFt7WSW~?utWh$9zw$xAC>J
zcN#p$=TYe0?UxnUP0go&W85WXi6_KDqJ=I=>km}(U*hBKamIDnNyNU^W{t%<la@nj
zdghut)IV%D-;^ucx^hr-M0k+r^Td}Q69cl{PVH}AdDZJZHhXaOj{Z%xYxK)&v*c3~
z6Wn9(MfryphMZ)FvXq!sBp<nrY$y3yMZs+x->{fSnHZT1QOWihS(kR@D-?N^3RZMI
zoP2hux#>;NM}vN)Z(DwEn^h51Uc7F_jC93@ql))-jO_iqKkXp@QJLf2Ck<?k&kUcH
zaqsq0_M0E*Og%)u$w(k3iI0Rfv4Igz^9=gn|H|ixr}g<M=j{&vDDIXarUu59`d_u)
z?TS)fvc+j#hUDF4)gljg?@rwvs~zg^+1MG;D%H?k+f%vmZfS8$!K2)x*;;9diO1tY
zxLYE0L*KIdS>8;7Tu81W^T|6*?O-ELOX$l8y=aAaW|DTg<HeyX_19-hnB|A6Pdv?R
zT>kprd$P}N*z)Je>C^nS3y+JdOZ}Bg-?~Kg$R2ZTNrR-rkId4nR-9IG9B|p;Ch8UB
z>lQE=G(dA<xDwxp?}P{8$rz*k4q^mweK&d?a^pRF#Bt~8`&OULDh}^6U}y*K*{%9?
ztNeNgDYkg*!f5`8>Cm5X!$p1l@3mh)Z)868slHk+cWdPOf;{#`oAit%-FU0$-iV%1
zOO8?S1Lk#dHMxMKlCI46ta|p2(3KHhT&*~2qFkDC_N83cg6QIZWfhg>wWBX6t&<()
zJxN1hV_{QV-dK_FWp0vt*7a_-Rlc$7kyetvoUxthVaqPcGKWvjI_LLzR{1pg+XoRe
zX@&;TNlXzbL>a@3?n7M}xZm%$*G_kVb1r9`Y<aD<k8eKu@ZcgH35~uTG{yc6TV;-}
zIK9|b(0bPLH|3jOfBwg*H-61>&xLCgD^g026j|k0T_Q8`lhrTmh{=fz3G3mM2QOrO
zB$eiVS;xsOOgifbJ2S*FJU7ZBmYT32l`qTsviP-iH(7TSA4okms4sZ6w|%^;exUqE
z*+d0TwQz;#m6iUon>Lkf7g1NxT%uQWX!h95iCmjuyH`%et~MUi-W&Yi1}>r1(*=n~
za}!cQ{A3i<hpB~uV}1|4B|Z3D38xEox;Dut;*ae;l&V|uUzFPR?U&`huaR20T~t+g
z8_$*r#UJ|y&UKZ&+w`ig?$V>O`=WQsZWLXe&bgLZo}!c>7V8|P9PSyim2Jmb$uuT;
z$z9}kas#U)cwxxBun&=bG0Y2-$?X}^Io0_UMZ&jpDuQcro=-FrZ?}K?*FX5J@Ats$
zh~U@79V<#@TsQtxwBH%8!PZeROgeh?xV?3aZRHu0b5wU#?*Ko&z*MRSy^e92m?mBm
zii7}zLfaFR?$7p_@R)LqajvjuQU)z1OiGQ`>L1in-qoc<*<8Bz^QzgU0wVKxrzdAd
z7Y-@)cz1NRc)rl6)v4r`$rcL~Xyv}iYEIpjI2o(T?G6_Vy~3_$Suov6VN#Z?AX}NP
z!A#DwFsaD&=&1OwNw?E`F1qKPD2%@)b#J74_UXZ<C$C*UsC`~NBKB*=jHJNoMT?h@
zNZnX(s8FH$YtL`(+XkDD95$CZ8FxC@@z~jTH%G5p-=Y91swh2#K_|wEL4rb<GU{kG
zL7D;keP4MFpHFpp?@)0{-OAET{&3!b5BpkoN2^F|^^v==x<TyCf;PV9zm4PXzW(V|
zc^}s%)!6Z*wQ5m$Oo{FF&?~|hhtgD%`r-tlQzCLg*K^hdXE9SradHV6MTRl?gJ;-Y
zp|%lExS4UiiHT{2+3T-N6s#>ty=zrPd6LnvxUI0$t@rTP{o^`+4fqTfXp3!F{cYWa
zEsIplcRTD;IZ$r=!?e}X=2VD-p-b-hSWgk(#Q~{71vCxDQKFalLxdCQjBWJ&)Xspv
zzL&k)-LlS3I*yzsPnMY{ACW)kw%=>-o*j(}J2v=Ar!3D~lqZlgll3car26yt2g5h@
zO|)lc9>(3{Ev+eR%iDKpLB`(X*YWS8%_DWg3OG^0Uzv5JJSjjrkh;vvEP~x0QW*X_
zsx-DcftpIq`gl3>TIo&6vKJ2?J|3&LXc=k0+RYmD8ugs?ofkOYd#UxRt!vviQIty6
zn>7pdbd0zrYzsMxoxP@WiEEjMp^uBdXpjbNm@Y*$5;H^*@tzSyucUef7WsL2SG#AO
zTk5phuGV_V3EpG5hJSSy{nxvbxovFYo;3~<eoF#`eExa-@%bM9rR)>`yP%h{bu%?9
z?+4!Acw@s=T8>JlVakgO_hME?4Tq_R%miz(c$oX<CPar6WE!x9*?J)}VG2<%WBM+f
zNjZ|4k#pdx;f?Iu`|fXiWLS6QrP90JPj|oMe9!)K`Cq<J?vi*3=QT3&McWpssr|Q3
zx888$G366|*1PQ#obH}`<IeW3@?!?pQ4{GsjN-XTe?dqPy>w+7Z;*w*y3a+A6jwQC
zJ$pWiy@iX3v=K)yPcvLyRjFvxtn9W`dP@!G>(ARisWWOeNbRm^S8RD!pZqxY!OuG}
zH>uYuFWY3DN`0P?5!)S=7G59X%}!<g$F!Y$9-GM~a-5kQT+T5IbB-K~9*IAmygB34
zrC)h{h4Q84_hKGidG@Qx?~Uxok<V=-jlW*bycT%9=;`tt>C+n~6&!Y??@iioeDMB}
zcJqrT7uqgAQ-1b`Te;UFzpnvDsOt0_2A7y1dWb{B4n{UDDrnaKj}O%|>il*W7l;2&
z-Lh;ny<oiHfW|(B-95@qTWZ$*krWe?TCj>w{IB@9>{snxqO+&fvth>*l`8MM)5Wg~
z_^xoX1JddeIdR3@!x8qOKiE?&CNqp&OfDxg$vmcFurlXX==BK6=;=74B%yTqi&w9(
zuiq|FE&p4^|MWm(W!tIu8~Ox?r^jdi^78X9oD%C?eMwGd>phj}-2&Q;2aFEW%q*<h
zPfa@9cHwvH_cZrC9MBxpO0#0v6JLojB7h(mf^<=8X231qqh3@u^|N7)-lu1*wwm)F
z;Tkk)H|&W~l~G`>ua@c(A6_`j|7E)G=g9E<&srZ+U&}PLJ*}<&Ret`KYT@C$#}|{+
zUnTj(bE4-*@`m|vY=aw^cSxDJ|158k!mMMJu$PC9hZ}H3;|vnNrvA)2ohx6US6o_l
zw$iaS<AqS`#STi(o}sN{Tc?zGRYeq*iAi>?jo7?E`Q$E7Ed%{_BPr7bmX|1R?F*d6
z&M)>%@hS8-2y&q<VyF;riN8cP@tEO6=Tg-I&-ktJc5vTy?$VjdwmR0F<DN$s8d~eP
zXzbqEs;IS*BU8Ada&eVl#cbK{``=pnc|V!HZEW^`ZdF6A=q*hy%FLg+bU))mvh#)0
zF?Eqw!)7_n!P2Zja_8KH93^F#=UD1&B4mF!Eow{b!GyMyXPHu$o3D1<P`mT-e*L5I
zI@4D@?^3$l2CRQrPT26+3R6T6u9TL2DSvW%nOetx4|Q!1l^wfx!ojA*F3m~GRmr2x
zo6rA#-~_dtKE<e<n~;YD4^czsqtyk9`ww^@@Yv~E=G0`zw&^_4aV+%EfG(eAms-g7
zX?a6g|CLdqvBFV2VG|KQG6tS@Ep8`XN!O1*5_n*JXZFVERgKG^Gry<UC1}USMwy03
zhv=|<SnHXlbMJIjvX2yJ)dv6IB!`tn8pa&C@F+Pe<HIFdzIRb&sab_`jq&rGX8E_T
zKj!vxzlHveoQ)BTUd&iwAtSc&s^a3E`!sgy^dB@nYJYs4HOH27X3aTccM)$hKlwl=
z)rS6nkumo?+6i@HIm3r`Jm`V{b)WT~ThBjn{$>A=qF||II&0*vpQgp$rKViAdC@v;
zNvmacA{1V$DXTH(p~#+w4%ODDFQRMXE8ELliVX|MT(NASG`mFkI2*1&#D>r+b_>gq
z=}*olrO9HlmU%qbi8B`ZJHjK{I=(C^DE;z9#XQkMgIi7I8P(UHjyIlvz3fA0U-fX=
z&+_R?{;Gwy#N(yR){kv<P|ewsr|o3$>9DZ*dn>ck=NzTa+Pm%b%Jz*8;G<5{0vJBT
zC^1Yp5q6A^wD&=j0B7I7o>Fd2E-M@-P6b+Jn|U4{KcJ|+aZjI$`_?A8`BIz2RTnDr
zD@<?sxntO*FY5hZn^&XaQ@LuZ^7fMa>vdQ3FRo8_N)nIX9$gjjC{&B19$duCAtlH~
zWH1@T{K4vDn}%vcq;uWkZYEl%xo7v}-YR%oY;;$oYQYozhO$<ZPO;vxq0eLeQ$xHX
zBA=JlOD3$_yXCGj?{2Yuefn<3*G%IqWlkA6EO+ra@95d*^Ua?KN}wq+^og#y|ExIT
zDnpxok~$Tz#;?&!$i3yP@|i8RH7Ea?cOCIQSh>G;Z_JJjirft^rGGBxTg)%`Z|3hW
z-fye>jX&nRk!@~%cK6|@d&Z^0MH2bMCH)M~WWfu<F|<g>u&11y;J?gPax2MC+K}qZ
zSe6s}en?n&V-zR$MuJYNR#xU^i)&|ZHr=5;aC@9tKd&XB-MD+>;PO$i$(8e@=1VM{
zx9XKFbCa+VMV+om(VIA=Z=!9{Ya?$j<V?6mc*yx2@c$XOk=99HN<5#NkWylRkwt$^
zjR|b_OYt6Ye|gTp>4Y7>jp+%)V?PWHbx-}LuJ&%5p?u<+hZ3zz-Uzk)Yy9)-d*7F(
zT{iDtz4WO&^2q7_liO}LT&_OIIiJZ)nYqv(voC6KxLJre`zUK6Q-5yKHOVPbjWrs)
zIixd;Kk9N!>4ohn;+fVtd{=pInBE?(Xsh}C{K(69Z^J*G{G$I|`;Y!VLm`7DY7&dq
zJlS}BTlvmDjaD6o;m4!H$8)V`Y=52MoV)67?VavtA6P;SroUkn%)QfJ66=VcbOV}9
zP>?^xr@^Dn)zX=?-%rW2C^2z1YSo+2{GcA8B)HjfZN#darTO!7=Veb`94#Jv-7VR{
zZjpL1_;~!mzOuJBtFO&oPR&YA{hRP2R)kv>J`fVcE@T-pok>A*16fP<GMT}d9M!P>
zkx!#5<JTsCOP9TLD=(|?!>zOTG#{Eg%Wjf>^YlafXa5n8U*0nT0s)K8E;o=C+K{8L
zWQW0C{r&R}dL2nHKXtPC^an@I*&4TKuL0kN05$4*dIEz({31RR=7cWeHZ4C$CP3OZ
z&-1}~2baqZv{Sz<#mqh!TO5emN9^9EQoTh|&UCfASl|LbKCizX<Fv0Cz3rWQ+MYFp
zK4DcoysKZb`nukg7uh9gvx#@&I=J2utWXio;@}u&EV-0iMkbKS%$30socPd?h#%aB
zxRpswX+zm(u4rCAThf2`dR57j(FVshf%kR21z)qrFaEv4m%kuOj9h&{?&}tNm2122
z>?02F9#%73VU>QW+JSIsJAdC($#+}8?VxJfA%-RKh4@J@2`)pDzM1+U;EivPSApBP
zvo(&zr!`M{nj0VKFp$~5W^bRWpF+oaNokGc2NxX_(4Eo#b#TPtbLxlD*FH^~o-Kc<
zbFchXP+?r&yi2dr1(S2*OQN?&%7w*n{DV80)#N%-h;${7G4HTa*ndKr!`E<oV#O0n
zQ_Hi~<n~;fzImo>b){JCffvOs`W<{d9|xO9n<iW4y_x@VY5A&<wJMwMC<*P7)tb_a
zHfl3@Zed5swD)oDaqaQ&^ojIW2r{Kj)8&blxnEWu@sbfpzd|(&4EH<W9p`@TT>F_%
zw!zl*$19Fn7#8Z>*NEP^Wn1dTE*W8oRZCV2N&FN0Bk^7Fi}k1LZ{=P#JilI3U$O1>
z$D;0hjhx>Z;wfntxG|%V^<k1B{lVK<Kgqpw6LOGT#<XOuVcUhQ2{((HiIGUiOo_~V
zpA&gC{>ISlnEL^bvg@W_hQHJ7S~l?S`}7~k3FHKF0y%-4Ku#bhkQ2xW<OFg8If0x&
zP9P_c6UYhV1Uo0#Il;~ec22N!f}IoWoM7h!J15vV!OjVGPOx)=ofGVwVCMuoC%D$Z
zwGOUzaIJ%D9bD_+S_juUxYoh74z6`@t%GYFT<hRk2iH2d)<Mn*a!!zQf}9iNoFL}}
zIVZ?DLCy(sPLOkgoD<}nAm;=*C&)QL&IuA?kr0c7SR}+EAr=X-NQgy3ED~ao5Q~IZ
zB*Y>i774LPh($sy5@OM<gKiyk>!4c)-8$&jLAMUNb<nMYZXI;%pj!vsI_TCxw+^~>
z(5-`3Vzd&Yl^CtWXeCA~F<ObyN{m)wv=XD07_G!;B}OYTT8Yt0j8<avO}VnID+fhK
zga>&(Pki|?F(BLR)c)ob<OFg8If0x&P9P_c6UYhV1abm7ft)~2ASaL$$O+^Gazc;`
z$yH=Nd55VTY{Y2^eHoz_tq{*lf}B83ASaL$$O+^GasoMloIp+>Cy*1!3FHKF0y%-4
zKu*G!xk>I>*SpzP`NpnCT1onH#&)KMExRa?6UYhV1abm7ft)~2ASaL$$O+^GasoMl
zoIp+>Cy*1!$(Y|mZ%Ge6SHkInovuytiTGoC52fms{0BLKoIp+>Cy*1!3FHKF0y%-4
zKu#bhkQ2xW<OFg8If0yT%VdiM3bb<HWHqO5OPq{V<#vY)hF)PqP9P_c6UYhV1abm7
zft)~2ASaL$$O+^GasoMloIp+>Cldv0OH%JzRZ*T~G%Ri_>~!lr{B{4h&R@t0<OFg8
zIf0x&P9P_c6UYhV1abm7ft)~2ASaL$$O+`6%)`*f#a}c?gEmZ;A{vPqqKJ6Uh@wMI
zASaL$$O+^GasoMloIp+>Cy*1!3FHKF0y%-4Ku#bhv$ES(=`A&!uRm}9q|T_>Aho-u
zU9sg^J>&#(0y%-4Ku#bhkQ2xW<OFg8If0x&P9P_c6UYhV1ah*NTux?^c}&G%WzMb8
z>k*RC({V;gLg|nb$O+^GasoMloIp+>Cy*1!3FHKF0y%-4Ku#bhkQ2y>m}J-5h|LR>
zPww*6GSF`~k}_Rjd5QAY9&!RXft)~2ASaL$$O+^GasoMloIp+>Cy*1!3FHKF0y!D*
zKH#y_walr>j&0L<qT^WTp#fb!%`P>_3FHKF0y%-4Ku#bhkQ2xW<OFg8If0x&P9P_c
z6UYhV#HHA<fXo%k7D}^Al#jFF3PfxOtzx&ZASaL$$O+^GasoMloIp+>Cy*1!3FHKF
z0y%-4Ku#bhkdwE?Mt4Q37Cg~!C~Gz86zd%u`aIS@HN*=!ft)~2ASaL$$O+^GasoMl
zoIp+>Cy*1!3FHKF0y%-4$oU-b{~5TE)=6JVJSS#}QeuFSMSo3&oIp+>Cy*1!3FHKF
z0y%-4Ku#bhkQ2xW<OFg8If0x&P9j$2EX|*vJ1=|k;%M>U>u$*oc8k=D!N-sj$O+^G
zasoMloIp+>Cy*1!3FHKF0y%-4Ku#bhkQ2zsGBSZoX08mD;KYZ9MEu}3#H~zfN*l_C
zoIp+>Cy*1!3FHKF0y%-4Ku#bhkQ2xW<OFg8If0x&PD0kIY`&u;v`bcNN-x@|&E&a-
z9VOG=#~E@0If0x&P9P_c6UYhV1abm7ft)~2ASaL$$O+^GasoN=_Bi7@>?C4eYqQ2;
zok`0fH9d399qJ#pLrx$kkQ2xW<OFg8If0x&P9P_c6UYhV1abm7ft)~2ASW>ek8+P@
zYo#S79*+y*Zi&zhear4=c{3p=kQ2xW<OFg8If0x&P9P_c6UYhV1abm7ft)~2ASaNM
ze`OVw<+Y<PD6Nwn<vmG5VPj!aT;5m_$O+^GasoMloIp+>Cy*1!3FHKF0y%-4Ku#bh
zkQ2xW<Ya^Y+rTBXdb%L-h?pfRh@XsN`Y^RH5OM-Jft)~2ASaL$$O+^GasoMloIp+>
zCy*1!3FHKF0y&voDj+hCcY1PWbm5Rvk9S9Bi{}fCTAfPB3FHKF0y%-4Ku#bhkQ2xW
z<OFg8If0x&P9P_c6UYhVB#I1U@(0hby+Umxo^UhcdJ_}V3bWT=ft)~2ASaL$$O+^G
zasoMloIp+>Cy*1!3FHKF0y%-4Ku+2>QIty6n>7pdbd0zrYzsMxoxP@Wi7Vs;asoMl
zoIp+>Cy*1!3FHKF0y%-4Ku#bhkQ2xW<OFh(;wtB?XU|8mw{S6$Hsa{zX@;w-Div*l
zoIp+>Cy*1!3FHKF0y%-4Ku#bhkQ2xW<OFg8If0x&PWY~HvjfuV5;<|j+`|#}p+DGD
zEG9FIgq%Q5ASaL$$O+^GasoMloIp+>Cy*1!3FHKF0y%-4Ku*q9I@V^q5Nf^HLFw5u
zv~_IjloGG1h{7_+3FHKF0y%-4Ku#bhkQ2xW<OFg8If0x&P9P_c6UYhV<bL1;wVXc1
zs3c~IhXfB%L+7K_1&aGaP9P_c6UYhV1abm7ft)~2ASaL$$O+^GasoMloIp+>Cw3wf
zUaKjqG3TMko`w$9)~7F`YvU{1%OEF^6UYhV1abm7ft)~2ASaL$$O+^GasoMloIp+>
zCy<jM<_}gM+cZ=oBAx3NcQesC%{{v(_f`Sq1abm7ft)~2ASaL$$O+^GasoMloIp+>
uCy*1!3FHKFBCJGFr)yI5CJyPFXj}B!$lD7!6Rr^+kQ2xW<mCTdPW}g3aj6Ud

literal 0
HcmV?d00001

diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
new file mode 100644
index 0000000000000000000000000000000000000000..f6b1c9e8f034b61fe79044681fc7dad958abf0e5
--- /dev/null
+++ b/app/src/main/res/values/strings.xml
@@ -0,0 +1,218 @@
+<resources>
+    <string name="app_name">EmberAudioPlayer3</string>
+    <string name="app_tagline">Your audio player.</string>
+
+    <string name="onboarding_brand_title">Ember</string>
+    <string name="onboarding_brand_subtitle">Your audio player</string>
+    <string name="onboarding_continue">Continue</string>
+    <string name="onboarding_permission_title">Play your local audio</string>
+    <string name="onboarding_permission_body">Ember scans your device to show your music. Nothing leaves your phone.</string>
+    <string name="onboarding_permission_allow">Allow access</string>
+    <string name="onboarding_permission_choose_folders">Choose folders instead</string>
+    <string name="onboarding_permission_error">Without access, Ember can’t find your music.</string>
+    <string name="onboarding_scanning_progress">Scanning… %1$d of %2$d</string>
+    <string name="onboarding_long_audio_title">Long audio found</string>
+    <string name="onboarding_long_audio_subtitle">We can organize longer recordings for you. You can change this anytime.</string>
+    <string name="onboarding_long_audio_count">%1$d items ≥ 20 min</string>
+    <string name="onboarding_long_audio_import_audiobooks">Import all as Audiobooks</string>
+    <string name="onboarding_long_audio_import_podcasts">Import all as Podcasts</string>
+    <string name="onboarding_long_audio_choose_individually">Choose individually</string>
+    <string name="onboarding_long_audio_skip">Skip for now</string>
+    <string name="onboarding_long_audio_hint">Change later in Longform or Settings ▸ Library.</string>
+    <string name="onboarding_long_audio_sort_header">Sort long audio (%1$d)</string>
+    <string name="onboarding_long_audio_apply">Apply</string>
+    <string name="onboarding_long_audio_music">Music</string>
+    <string name="onboarding_long_audio_podcast">Podcast</string>
+    <string name="onboarding_long_audio_audiobook">Audiobook</string>
+    <string name="onboarding_long_audio_suggested">Suggested: %1$s</string>
+    <string name="onboarding_long_audio_sorted_audiobooks">Sorted to Audiobooks.</string>
+    <string name="onboarding_long_audio_sorted_podcasts">Sorted to Podcasts.</string>
+    <string name="onboarding_long_audio_sorted_music">Sorted to Music.</string>
+    <string name="onboarding_long_audio_applied">Sorting applied.</string>
+    <string name="onboarding_long_audio_undo_message">Sorting reverted.</string>
+    <string name="onboarding_undo">Undo</string>
+    <string name="onboarding_theme_title">Pick a look</string>
+    <string name="onboarding_theme_hint">More customization anytime in Theme Studio.</string>
+    <string name="onboarding_theme_dark_toggle">Use dark theme</string>
+    <string name="onboarding_finish">Finish</string>
+
+    <string name="play_action">Play</string>
+    <string name="pause_action">Pause</string>
+    <string name="play_content_description">Play sample</string>
+    <string name="pause_content_description">Pause playback</string>
+    <string name="playback_position_description">%1$s of %2$s played</string>
+    <string name="share_song_action">Share</string>
+    <string name="share_song_content_description">Share current song</string>
+    <string name="share_song_row_content_description">Share %1$s</string>
+    <string name="share_song_subject">Listening to %1$s</string>
+    <string name="share_song_text">Listening to %1$s — %2$s in Ember Audio Player.</string>
+    <string name="share_song_chooser_title">Share song</string>
+    <string name="share_song_error">No app available to share right now.</string>
+
+    <string name="songs_tab">Songs</string>
+    <string name="playlists_tab">Playlists</string>
+    <string name="folders_tab">Folders</string>
+    <string name="albums_tab">Albums</string>
+    <string name="artists_tab">Artists</string>
+    <string name="genres_tab">Genres</string>
+    <string name="longform_tab">Longform</string>
+    <string name="videos_tab">Videos</string>
+    <string name="equalizer_tab">Equalizer</string>
+    <string name="lyrics_tab">Lyrics</string>
+    <string name="themes_tab">Themes</string>
+    <string name="tags_tab">Tag editor</string>
+
+    <string name="drawer_title">Navigate</string>
+    <string name="drawer_library">Library</string>
+    <string name="drawer_equalizer">Equalizer</string>
+    <string name="drawer_sleep_timer">Sleep timer</string>
+    <string name="drawer_theme_studio">Theme Studio</string>
+    <string name="drawer_widgets">Widgets</string>
+    <string name="drawer_scan_import">Scan &amp; import</string>
+    <string name="drawer_settings">Settings</string>
+    <string name="drawer_help">Help &amp; about</string>
+
+    <string name="drawer_toggle_content_description">Open navigation drawer</string>
+    <string name="search_content_description">Search library</string>
+    <string name="search_title">Search</string>
+    <string name="search_field_placeholder">Search your library</string>
+    <string name="search_close_content_description">Close search</string>
+    <string name="search_clear_content_description">Clear search text</string>
+    <string name="search_hint">Start typing to search your songs, playlists, and more.</string>
+    <string name="search_no_results">No matches yet. Try a different keyword.</string>
+    <string name="search_overlay_content_description">Library search overlay</string>
+    <string name="search_view_all">View all</string>
+    <string name="search_bucket_all">All</string>
+    <string name="search_bucket_songs">Songs</string>
+    <string name="search_bucket_playlists">Playlists</string>
+    <string name="search_bucket_folders">Folders</string>
+    <string name="search_bucket_albums">Albums</string>
+    <string name="search_bucket_artists">Artists</string>
+    <string name="search_bucket_genres">Genres</string>
+    <string name="search_bucket_longform">Longform</string>
+    <string name="search_bucket_videos">Videos</string>
+    <string name="search_section_songs">Songs</string>
+    <string name="search_section_playlists">Playlists</string>
+    <string name="search_section_folders">Folders</string>
+    <string name="search_section_albums">Albums</string>
+    <string name="search_section_artists">Artists</string>
+    <string name="search_section_genres">Genres</string>
+    <string name="search_section_longform">Longform</string>
+    <string name="search_section_videos">Videos</string>
+    <string name="search_playlist_subtitle">%1$d tracks • %2$s</string>
+    <string name="search_folder_subtitle">%1$s • %2$d tracks</string>
+    <string name="search_album_subtitle">%1$s • %2$d tracks</string>
+    <string name="search_artist_subtitle">%1$d albums • %2$d tracks</string>
+    <string name="search_genre_subtitle">%1$d tracks</string>
+    <string name="search_longform_subtitle">%1$s • %2$s</string>
+    <string name="theme_studio_content_description">Open Theme Studio</string>
+    <string name="settings_content_description">Open settings</string>
+
+    <string name="songs_tab_count">%1$d songs</string>
+    <string name="songs_shuffle_all_button">Shuffle all</string>
+    <string name="songs_play_all_button">Play all</string>
+    <string name="song_row_subtitle">%1$s • %2$s</string>
+    <string name="songs_sort_label">Sort</string>
+    <string name="song_sort_field_title">Title</string>
+    <string name="song_sort_field_added">Recently added</string>
+    <string name="song_sort_field_duration">Duration</string>
+    <string name="sort_direction_ascending">Ascending</string>
+    <string name="sort_direction_descending">Descending</string>
+    <string name="songs_sort_direction_title_ascending">Sorted by title A–Z</string>
+    <string name="songs_sort_direction_title_descending">Sorted by title Z–A</string>
+    <string name="songs_sort_direction_added_descending">Sorted by newest first</string>
+    <string name="songs_sort_direction_added_ascending">Sorted by oldest first</string>
+    <string name="songs_sort_direction_duration_ascending">Sorted by shortest first</string>
+    <string name="songs_sort_direction_duration_descending">Sorted by longest first</string>
+    <string name="songs_now_playing_indicator_playing">Now playing, audio is playing</string>
+    <string name="songs_now_playing_indicator_paused">Now playing, paused</string>
+    <string name="playlists_tab_count">%1$d playlists</string>
+    <string name="playlist_row_subtitle">%1$d tracks • %2$s</string>
+    <string name="folders_tab_count">%1$d folders</string>
+    <string name="folder_row_track_count">%1$d tracks</string>
+    <string name="albums_tab_count">%1$d albums</string>
+    <string name="albums_sort_direction_ascending">Albums sorted A–Z</string>
+    <string name="albums_sort_direction_descending">Albums sorted Z–A</string>
+    <string name="album_row_track_count">%1$d tracks</string>
+    <string name="artists_tab_count">%1$d artists</string>
+    <string name="artists_sort_direction_ascending">Artists sorted A–Z</string>
+    <string name="artists_sort_direction_descending">Artists sorted Z–A</string>
+    <string name="artist_row_detail">%1$d albums • %2$d tracks</string>
+    <string name="genres_tab_count">%1$d genres</string>
+    <string name="genre_row_track_count">%1$d tracks</string>
+    <string name="videos_tab_count">%1$d videos</string>
+
+    <string name="longform_filter_all">All</string>
+    <string name="longform_filter_podcasts">Podcasts</string>
+    <string name="longform_filter_audiobooks">Audiobooks</string>
+    <string name="longform_filter_unassigned">Unassigned</string>
+    <string name="longform_row_source">From %1$s</string>
+
+    <string name="now_playing_title">Now playing</string>
+    <string name="now_playing_artist_album">%1$s • %2$s</string>
+
+    <string name="mini_player_previous_content_description">Play previous track</string>
+    <string name="mini_player_next_content_description">Play next track</string>
+    <string name="mini_player_queue_content_description">Open queue</string>
+
+    <string name="queue_title">Now playing queue</string>
+    <string name="queue_now_playing">Currently playing</string>
+    <string name="queue_history_header">Previously played</string>
+    <string name="queue_up_next_header">Up next</string>
+    <string name="queue_remove_content_description">Remove from queue</string>
+    <string name="queue_remove_label">Remove</string>
+    <string name="queue_empty_up_next">No upcoming songs. Add more from your library.</string>
+
+    <string name="placeholder_sleep_timer">Sleep timer controls arrive soon.</string>
+    <string name="placeholder_widgets">Widget gallery is under construction.</string>
+    <string name="placeholder_scan_import">Scanning and import tools will land with the library engine.</string>
+    <string name="placeholder_settings">Settings are coming in a later slice.</string>
+    <string name="placeholder_help">Help and support content will appear here.</string>
+
+    <string name="sample_tone_title">Sample tone</string>
+    <string name="sample_tone_artist">Ember Audio</string>
+    <string name="sample_album_title">Sample collection</string>
+
+    <string name="equalizer_enable_label">Equalizer</string>
+    <string name="equalizer_preset_label">Presets</string>
+    <string name="equalizer_no_presets">No presets available</string>
+    <string name="equalizer_not_available">Equalizer effects are not available on this device.</string>
+    <string name="equalizer_gain_value">%1$.1f dB</string>
+    <string name="equalizer_bass_boost_label">Bass boost</string>
+    <string name="equalizer_virtualizer_label">Virtualizer</string>
+    <string name="equalizer_reverb_label">Reverb</string>
+
+    <string name="reverb_none">None</string>
+    <string name="reverb_small_room">Small room</string>
+    <string name="reverb_medium_room">Medium room</string>
+    <string name="reverb_large_room">Large room</string>
+    <string name="reverb_medium_hall">Medium hall</string>
+    <string name="reverb_large_hall">Large hall</string>
+    <string name="reverb_plate">Plate</string>
+
+    <string name="lyrics_input_label">Lyrics</string>
+    <string name="lyrics_input_hint">Paste or type lyrics for the current track</string>
+    <string name="lyrics_save_button">Save</string>
+    <string name="lyrics_clear_button">Clear</string>
+    <string name="lyrics_load_sample_button">Load sample</string>
+    <string name="lyrics_empty_state">No lyrics yet. Add them above.</string>
+    <string name="lyrics_saved_message">Lyrics saved.</string>
+    <string name="lyrics_cleared_message">Lyrics cleared.</string>
+    <string name="lyrics_sample_loaded_message">Sample lyrics loaded.</string>
+    <string name="sample_lyrics_body">Glowing ember in the dark\nKeeps the rhythm, beats the spark\nFeel the warmth of molten light\nEmber guides your song tonight</string>
+
+    <string name="theme_dark_mode_label">Use dark mode</string>
+    <string name="theme_option_ember">Ember Classic</string>
+    <string name="theme_option_night">Night Copper</string>
+    <string name="theme_option_graphite">Mono Graphite</string>
+    <string name="theme_preview_hint">Preview palette</string>
+    <string name="dark_mode_on">On</string>
+    <string name="dark_mode_off">Off</string>
+
+    <string name="tag_editor_title_label">Title</string>
+    <string name="tag_editor_artist_label">Artist</string>
+    <string name="tag_editor_album_label">Album</string>
+    <string name="tag_editor_save_button">Save changes</string>
+    <string name="tag_editor_reset_button">Reset</string>
+    <string name="tag_editor_saved_message">Tags updated.</string>
+</resources>
diff --git a/app/src/main/res/values/themes.xml b/app/src/main/res/values/themes.xml
new file mode 100644
index 0000000000000000000000000000000000000000..73ce1242d63905ad56169ab2490376e1ea27a004
--- /dev/null
+++ b/app/src/main/res/values/themes.xml
@@ -0,0 +1,3 @@
+<resources>
+    <style name="Theme.EmberAudioStudio3" parent="Theme.Material3.DayNight.NoActionBar" />
+</resources>
diff --git a/app/src/test/java/app/ember/studio/LibrarySortingTest.kt b/app/src/test/java/app/ember/studio/LibrarySortingTest.kt
new file mode 100644
index 0000000000000000000000000000000000000000..14dba5e9a7b309097a93d669efb8afe6bb8d8fb8
--- /dev/null
+++ b/app/src/test/java/app/ember/studio/LibrarySortingTest.kt
@@ -0,0 +1,90 @@
+package app.ember.studio
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class LibrarySortingTest {
+    private val songA = SongSummary(
+        id = "a",
+        title = "Afterglow",
+        artist = "Artist A",
+        album = "Album A",
+        durationMs = 120_000,
+        rawResId = null,
+        addedTimestampMs = 2L
+    )
+    private val songB = SongSummary(
+        id = "b",
+        title = "Beacon",
+        artist = "Artist B",
+        album = "Album B",
+        durationMs = 240_000,
+        rawResId = null,
+        addedTimestampMs = 3L
+    )
+    private val songC = SongSummary(
+        id = "c",
+        title = "Chroma",
+        artist = "Artist C",
+        album = "Album C",
+        durationMs = 90_000,
+        rawResId = null,
+        addedTimestampMs = 1L
+    )
+
+    private val albumA = AlbumSummary(id = "a", title = "Aurora", artist = "Artist A", trackCount = 10)
+    private val albumB = AlbumSummary(id = "b", title = "Bloom", artist = "Artist B", trackCount = 8)
+
+    private val artistA = ArtistSummary(id = "a", name = "Aria", albumCount = 1, trackCount = 10)
+    private val artistB = ArtistSummary(id = "b", name = "Coda", albumCount = 2, trackCount = 14)
+
+    @Test
+    fun `sortSongs sorts by title ascending by default`() {
+        val state = SongSortState(field = SongSortField.Title, direction = SortDirection.Ascending)
+        val sorted = sortSongs(listOf(songB, songC, songA), state)
+
+        assertEquals(listOf("a", "b", "c"), sorted.map { it.id })
+    }
+
+    @Test
+    fun `sortSongs sorts by title descending`() {
+        val state = SongSortState(field = SongSortField.Title, direction = SortDirection.Descending)
+        val sorted = sortSongs(listOf(songA, songB, songC), state)
+
+        assertEquals(listOf("c", "b", "a"), sorted.map { it.id })
+    }
+
+    @Test
+    fun `sortSongs sorts by added timestamp newest first`() {
+        val state = SongSortState(field = SongSortField.Added, direction = SortDirection.Descending)
+        val sorted = sortSongs(listOf(songA, songB, songC), state)
+
+        assertEquals(listOf("b", "a", "c"), sorted.map { it.id })
+    }
+
+    @Test
+    fun `sortSongs sorts by duration ascending`() {
+        val state = SongSortState(field = SongSortField.Duration, direction = SortDirection.Ascending)
+        val sorted = sortSongs(listOf(songA, songB, songC), state)
+
+        assertEquals(listOf("c", "a", "b"), sorted.map { it.id })
+    }
+
+    @Test
+    fun `sortAlbums honors sort direction`() {
+        val ascending = sortAlbums(listOf(albumB, albumA), SortDirection.Ascending)
+        val descending = sortAlbums(listOf(albumA, albumB), SortDirection.Descending)
+
+        assertEquals(listOf("a", "b"), ascending.map { it.id })
+        assertEquals(listOf("b", "a"), descending.map { it.id })
+    }
+
+    @Test
+    fun `sortArtists honors sort direction`() {
+        val ascending = sortArtists(listOf(artistB, artistA), SortDirection.Ascending)
+        val descending = sortArtists(listOf(artistA, artistB), SortDirection.Descending)
+
+        assertEquals(listOf("a", "b"), ascending.map { it.id })
+        assertEquals(listOf("b", "a"), descending.map { it.id })
+    }
+}
diff --git a/app/src/test/java/app/ember/studio/LongformHeuristicsTest.kt b/app/src/test/java/app/ember/studio/LongformHeuristicsTest.kt
new file mode 100644
index 0000000000000000000000000000000000000000..a61e0a7754e6404099b0478369b61643bab60225
--- /dev/null
+++ b/app/src/test/java/app/ember/studio/LongformHeuristicsTest.kt
@@ -0,0 +1,67 @@
+package app.ember.studio
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class LongformHeuristicsTest {
+
+    @Test
+    fun `existing category is honored`() {
+        val result = suggestLongformCategory(
+            title = "Daily Spark Episode 4",
+            source = "Spark Radio",
+            existingCategory = LongformCategory.Podcast,
+            durationMs = 35 * 60 * 1000L
+        )
+
+        assertEquals(LongformCategory.Podcast, result)
+    }
+
+    @Test
+    fun `podcast tokens are detected`() {
+        val result = suggestLongformCategory(
+            title = "Molten Show Episode 12",
+            source = "Helix Radio",
+            existingCategory = LongformCategory.Unassigned,
+            durationMs = 45 * 60 * 1000L
+        )
+
+        assertEquals(LongformCategory.Podcast, result)
+    }
+
+    @Test
+    fun `audiobook tokens are detected`() {
+        val result = suggestLongformCategory(
+            title = "Molten Chapter 3",
+            source = "Molten Saga",
+            existingCategory = LongformCategory.Unassigned,
+            durationMs = 75 * 60 * 1000L
+        )
+
+        assertEquals(LongformCategory.Audiobook, result)
+    }
+
+    @Test
+    fun `long duration defaults to audiobook`() {
+        val result = suggestLongformCategory(
+            title = "Three Hour Ambient Journey",
+            source = "Ember Archive",
+            existingCategory = LongformCategory.Unassigned,
+            durationMs = LONGFORM_AUDIOBOOK_DURATION_MS + 1_000L
+        )
+
+        assertEquals(LongformCategory.Audiobook, result)
+    }
+
+    @Test
+    fun `unknown tokens remain unassigned`() {
+        val result = suggestLongformCategory(
+            title = "Soundscape Session",
+            source = "Ember Archive",
+            existingCategory = LongformCategory.Unassigned,
+            durationMs = 30 * 60 * 1000L
+        )
+
+        assertEquals(LongformCategory.Unassigned, result)
+    }
+}
diff --git a/app/src/test/java/app/ember/studio/SearchModelsTest.kt b/app/src/test/java/app/ember/studio/SearchModelsTest.kt
new file mode 100644
index 0000000000000000000000000000000000000000..6b7b2457d2d1fecafcb4e0bc9804969deb3af084
--- /dev/null
+++ b/app/src/test/java/app/ember/studio/SearchModelsTest.kt
@@ -0,0 +1,110 @@
+package app.ember.studio
+
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class SearchModelsTest {
+    private val sampleCorpus = SearchCorpus(
+        songs = listOf(
+            SongSummary(
+                id = "song-1",
+                title = "Molten Heart",
+                artist = "The Embers",
+                album = "Glow",
+                durationMs = 180_000,
+                rawResId = null,
+                addedTimestampMs = 0L
+            ),
+            SongSummary(
+                id = "song-2",
+                title = "Dawn Chorus",
+                artist = "Aurora Fields",
+                album = "Sunrise",
+                durationMs = 210_000,
+                rawResId = null,
+                addedTimestampMs = 0L
+            )
+        ),
+        playlists = listOf(
+            PlaylistSummary(
+                id = "playlist-1",
+                title = "Morning Mix",
+                trackCount = 12,
+                totalDurationMs = 2_700_000
+            )
+        ),
+        folders = listOf(
+            FolderSummary(
+                id = "folder-1",
+                name = "Audiobooks",
+                path = "/storage/Audiobooks",
+                trackCount = 24
+            )
+        ),
+        albums = listOf(
+            AlbumSummary(
+                id = "album-1",
+                title = "Glow",
+                artist = "The Embers",
+                trackCount = 8
+            )
+        ),
+        artists = listOf(
+            ArtistSummary(
+                id = "artist-1",
+                name = "The Embers",
+                albumCount = 2,
+                trackCount = 18
+            )
+        ),
+        genres = listOf(
+            GenreSummary(
+                id = "genre-1",
+                name = "Ambient",
+                trackCount = 42
+            )
+        ),
+        longform = listOf(
+            LongformItem(
+                id = "longform-1",
+                title = "Deep Focus Session",
+                category = LongformCategory.Podcast,
+                durationMs = 3_600_000,
+                source = "Focus Studio"
+            )
+        ),
+        videos = listOf(
+            VideoSummary(
+                id = "video-1",
+                title = "Molten Heart (Live)",
+                durationMs = 240_000
+            )
+        )
+    )
+
+    @Test
+    fun searchLibrary_matchesAcrossFields() {
+        val results = searchLibrary(sampleCorpus, "Molten")
+
+        assertEquals(1, results.songs.size)
+        assertEquals("song-1", results.songs.first().id)
+        assertEquals(1, results.videos.size)
+        assertTrue(results.playlists.isEmpty())
+    }
+
+    @Test
+    fun searchLibrary_isCaseInsensitive() {
+        val results = searchLibrary(sampleCorpus, "aurora")
+
+        assertEquals(1, results.songs.size)
+        assertEquals("song-2", results.songs.first().id)
+    }
+
+    @Test
+    fun searchLibrary_returnsEmptyResultsForBlankQuery() {
+        val results = searchLibrary(sampleCorpus, "   ")
+
+        assertTrue(results.isEmpty)
+    }
+}
diff --git a/app/src/test/java/app/ember/studio/util/AudioFormatTest.kt b/app/src/test/java/app/ember/studio/util/AudioFormatTest.kt
new file mode 100644
index 0000000000000000000000000000000000000000..d2e4147923514ebed32b78e654178d6ee9c5d1af
--- /dev/null
+++ b/app/src/test/java/app/ember/studio/util/AudioFormatTest.kt
@@ -0,0 +1,27 @@
+package app.ember.studio.util
+
+import kotlin.test.Test
+import kotlin.test.assertEquals
+
+class AudioFormatTest {
+    @Test
+    fun formatFrequencyLabel_handlesHertzBelowOneKilohertz() {
+        assertEquals("60 Hz", formatFrequencyLabel(60_000))
+        assertEquals("230 Hz", formatFrequencyLabel(230_000))
+    }
+
+    @Test
+    fun formatFrequencyLabel_handlesKilohertzWithDecimal() {
+        assertEquals("0 Hz", formatFrequencyLabel(0))
+        assertEquals("0 Hz", formatFrequencyLabel(500))
+        assertEquals("0 Hz", formatFrequencyLabel(999))
+        assertEquals("1.0 kHz", formatFrequencyLabel(1_000_000))
+        assertEquals("2.3 kHz", formatFrequencyLabel(2_300_000))
+    }
+
+    @Test
+    fun formatFrequencyLabel_roundsHighKilohertz() {
+        assertEquals("10 kHz", formatFrequencyLabel(10_000_000))
+        assertEquals("15 kHz", formatFrequencyLabel(15_000_000))
+    }
+}
diff --git a/app/src/test/java/app/ember/studio/util/FormatDurationTest.kt b/app/src/test/java/app/ember/studio/util/FormatDurationTest.kt
new file mode 100644
index 0000000000000000000000000000000000000000..97006a71e9e3f0f5766cf9830c5582d281cbc3ec
--- /dev/null
+++ b/app/src/test/java/app/ember/studio/util/FormatDurationTest.kt
@@ -0,0 +1,21 @@
+package app.ember.studio.util
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+class FormatDurationTest {
+    @Test
+    fun `formats sub-minute durations`() {
+        assertEquals("0:05", formatDuration(5_000))
+    }
+
+    @Test
+    fun `formats minutes`() {
+        assertEquals("3:20", formatDuration(200_000))
+    }
+
+    @Test
+    fun `formats hours`() {
+        assertEquals("1:03:05", formatDuration(3_785_000))
+    }
+}
diff --git a/build.gradle.kts b/build.gradle.kts
index 13ecc1f226c18a95d415f9ef026656f6282ed689..660b36cdb4ae515ff941b8e24c9b3851e230efe5 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -1,18 +1,19 @@
-// Top-level build file for Ember Audio Player.
+// Top-level Gradle configuration for EmberAudioStudio3.
 
 plugins {
     id("com.android.application") version "8.12.0" apply false
     id("org.jetbrains.kotlin.android") version "2.1.20" apply false
     id("org.jetbrains.kotlin.plugin.compose") version "2.1.20" apply false
-    id("com.google.devtools.ksp") version "2.1.20-1.0.32" apply false
-    id("com.google.dagger.hilt.android") version "2.57.1" apply false
-    id("com.google.protobuf") version "0.9.4" apply false
+    id("io.gitlab.arturbosch.detekt") version "1.23.8"
+    id("org.jlleitschuh.gradle.ktlint") version "13.1.0"
 }
 
-allprojects {
-    // Repositories are defined centrally in settings.gradle.kts
+detekt {
+    buildUponDefaultConfig = true
+    allRules = false
+    config.setFrom(files("$rootDir/config/detekt/detekt.yml"))
 }
 
-tasks.register("clean", Delete::class) {
-    delete(layout.buildDirectory)
+ktlint {
+    android.set(true)
 }
diff --git a/config/detekt/detekt.yml b/config/detekt/detekt.yml
new file mode 100644
index 0000000000000000000000000000000000000000..36121b02a52cd578d8b7958201f119db05fe30ac
--- /dev/null
+++ b/config/detekt/detekt.yml
@@ -0,0 +1,9 @@
+build:
+  maxIssues: 0
+config:
+  validation: true
+style:
+  MagicNumber:
+    active: false
+  WildcardImport:
+    active: true
diff --git a/docs/MASTER_PROMPT.md b/docs/MASTER_PROMPT.md
index 66ac41637f90c702755a1c96f1fadefb6e1a3d8b..fceb8c20ad47f5a520d2d8e946520e3e4ca2c7ad 100644
--- a/docs/MASTER_PROMPT.md
+++ b/docs/MASTER_PROMPT.md
@@ -1,26 +1,47 @@
-﻿# AGENTS.md — Ember Audio Player (Android)
+# EmberAudioPlayer3 — Operating Prompt v2
 
-Follow docs/MASTER_PROMPT.md exactly.
+## Research Gate (validated pins)
 
-Absolute rules:
-- Windows paths only. Create every missing folder/file before referencing.
-- When updating a file, output the FULL FINAL FILE (no diffs).
-- Kotlin 2.1.20, Compose via BOM (no kotlinCompilerExtensionVersion), AGP 8.12.0, Gradle 8.13. AndroidX only.
-- minSdk 24; target/compile 35; Media3 1.8.0 playback; no legacy support libs.
-- Do NOT build Android in the cloud. Generate correct files; I will compile locally.
-- Work in phases. After each phase: commit → push to 'codex/dev' → open a PR → STOP.
+* **Android Gradle Plugin 8.12.0** pairs with **Gradle 8.13** for this project.
+* **Kotlin 2.1.20 (K2)** is the language baseline.
+* **Compose BOM 2025.06.00** controls all Compose artifact versions.
+* **Media3 1.8.0** is the supported playback stack.
+* **Activity Compose 1.9.2** and **core-ktx 1.12.0** fit the compileSdk 35 baseline.
+* **minSdk 24 / targetSdk 35** keep the app compliant with Play policy.
 
-## Internet allowlist (comma-separated)
-developer.android.com,kotlinlang.org,kdoc.dev,javadoc.io,services.gradle.org,plugins.gradle.org,dl.google.com,maven.google.com,repo.maven.apache.org,repo1.maven.org,musicbrainz.org,coverartarchive.org,itunes.apple.com
+## Operating Rules
 
-## Internet policy (cloud tasks that CAN edit the repo)
-Allowed (GET/HEAD only) to the domains above.
-Banned: uploading repo code/secrets; installing SDKs/packages; 'curl | bash'; auto-bumping versions.
-If a new domain is needed, propose it in the PR; do not proceed without approval.
+```
+ROLE: EmberAudioPlayer3 Android Engineer (research-first, zero hallucinations)
 
-## Self-audit before each commit
-- Only AndroidX/Media3 imports; all referenced resources exist; versions match pins.
+NON-NEGOTIABLES
+- Do not invent APIs. Verify changes against official documentation when in doubt.
+- Keep the build green. No unresolved symbols or TODOs left in committed code.
+- Stay within the pinned versions above. Document upgrades before attempting them.
 
-## Fallbacks used for compileSdk 35
-- androidx.core:core-ktx 1.16.0 (1.17.0 requires compileSdk 36)
-- androidx.activity:activity-compose 1.10.1 (1.11.0 requires compileSdk 36)
+ARCHITECTURE BASELINE
+- Single-activity Compose app using Material3.
+- No Hilt/KSP; prefer simple ViewModel + AndroidViewModel patterns.
+- Media playback is handled with Media3 ExoPlayer inside a ViewModel.
+- Persistence is currently out of scope.
+
+QUALITY BAR
+- Material3 styling, dark/light aware.
+- Accessible text (TalkBack labels, contrast) for any new UI.
+- Compose previews optional but welcome.
+- Unit tests required for pure Kotlin utilities.
+
+WORKFLOW
+1. Plan: outline intent, risks, and files to touch.
+2. Implement: keep changes cohesive and compiling.
+3. Verify: run `:app:assembleDebug` and relevant unit tests.
+4. Document: summarize code + tests, note any follow-ups.
+
+SELF-AUDIT CHECKLIST
+[ ] Project compiles with AGP 8.12.0 / Kotlin 2.1.20 / Compose BOM 2025.06.00
+[ ] minSdk 24, target/compile 35
+[ ] Media3 1.8.0 wired correctly
+[ ] No unresolved warnings or unused imports
+[ ] Tests updated/executed when logic changes
+[ ] AndroidX (plus Kotlin stdlib/coroutines) dependencies only
+```
diff --git a/gradle.properties b/gradle.properties
index 24f9303d8ad93b12573543076f084e767bea11a2..618e796cdf3e50e53e27df44318f732671fef8a1 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,8 +1,12 @@
-# Ember Audio Player - Gradle properties
-org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# Performance & stability
+org.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=1g -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+org.gradle.configuration-cache=true
+org.gradle.caching=true
+kotlin.code.style=official
+kotlin.incremental=true
 android.useAndroidX=true
-# No Jetifier (no legacy support libs)
 android.enableJetifier=false
 android.nonTransitiveRClass=true
-kotlin.code.style=official
 
+# Compose compiler uses Kotlin K2
+kotlin.daemon.jvmargs=-Xmx2g
diff --git a/gradlew b/gradlew
old mode 100644
new mode 100755
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 5b6d81a70a4befe2f2f7f6810e0dcd649ede51a7..d59c5816549b91600d786bd668da75f1225adb9b 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -1,22 +1,18 @@
 pluginManagement {
     repositories {
         google()
         mavenCentral()
         gradlePluginPortal()
     }
-    plugins {
-        id("com.android.application") version "8.12.0"
-        id("org.jetbrains.kotlin.android") version "2.1.20"
-    }
 }
 
 dependencyResolutionManagement {
     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
     repositories {
         google()
         mavenCentral()
     }
 }
 
-rootProject.name = "EmberAudioPlayer"
+rootProject.name = "EmberAudioStudio3"
 include(":app")
